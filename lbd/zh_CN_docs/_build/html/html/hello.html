<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cpu0 architecture and LLVM structure &mdash; cpu0-llvm-backend 0.1 文档</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7c91f8fd"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/translations.js?v=beaddf03"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            cpu0-llvm-backend
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Cpu0 architecture and LLVM structure</a><ul>
<li><a class="reference internal" href="#cpu0">CPU0 处理器架构细节</a><ul>
<li><a class="reference internal" href="#id3">概要介绍</a></li>
<li><a class="reference internal" href="#id6">Cpu0 指令集</a><ul>
<li><a class="reference internal" href="#addsub">为什么不使用ADD而使用SUB?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">状态寄存器</a></li>
<li><a class="reference internal" href="#id26">CPU0的指令执行阶段</a></li>
<li><a class="reference internal" href="#id27">CPU0的中断向量</a></li>
</ul>
</li>
<li><a class="reference internal" href="#llvm-structure-llvm">LLVM Structure（译者：本节是llvm一些基础介绍，熟悉的同学可以直接跳过）</a><ul>
<li><a class="reference internal" href="#three-phase-design">Three-phase design</a></li>
<li><a class="reference internal" href="#llvm-s-target-description-files-td">LLVM’s Target Description Files: .td</a></li>
<li><a class="reference internal" href="#llvm-code-generation-sequence">LLVM Code Generation Sequence</a></li>
<li><a class="reference internal" href="#ssa-form">SSA form</a></li>
<li><a class="reference internal" href="#dsa-form">DSA form</a></li>
<li><a class="reference internal" href="#llvm-vs-gcc-in-structure">LLVM vs GCC in structure</a></li>
<li><a class="reference internal" href="#llvm-blog">LLVM blog</a></li>
<li><a class="reference internal" href="#cfg-control-flow-graph">CFG (Control Flow Graph)</a></li>
<li><a class="reference internal" href="#dag-directed-acyclic-graph">DAG (Directed Acyclic Graph)</a></li>
<li><a class="reference internal" href="#instruction-selection">Instruction Selection</a></li>
<li><a class="reference internal" href="#caller-and-callee-saved-registers">Caller and callee saved registers</a></li>
<li><a class="reference internal" href="#live-in-and-live-out-register">Live in and live out register</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id47">创建Cpu0后端</a><ul>
<li><a class="reference internal" href="#cpu0-id">CPU0 后端机器 ID 和重定位记录</a></li>
<li><a class="reference internal" href="#cpu0-td">创建初始的 Cpu0 .td 文件</a></li>
<li><a class="reference internal" href="#cmake">编写 cmake 文件</a></li>
<li><a class="reference internal" href="#target-registration">Target Registration</a></li>
<li><a class="reference internal" href="#build-libraries-and-td">Build libraries and td</a></li>
</ul>
</li>
<li><a class="reference internal" href="#options-of-llc-for-debug">Options of llc for debug</a></li>
<li><a class="reference internal" href="#options-of-opt">Options of opt</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cpu0-llvm-backend</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Cpu0 architecture and LLVM structure</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/hello.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="cpu0-architecture-and-llvm-structure">
<span id="sec-llvmstructure"></span><h1>Cpu0 architecture and LLVM structure<a class="headerlink" href="#cpu0-architecture-and-llvm-structure" title="Link to this heading"></a></h1>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#cpu0" id="id83">CPU0 处理器架构细节</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id84">概要介绍</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id85">Cpu0 指令集</a></p>
<ul>
<li><p><a class="reference internal" href="#addsub" id="id86">为什么不使用ADD而使用SUB?</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id25" id="id87">状态寄存器</a></p></li>
<li><p><a class="reference internal" href="#id26" id="id88">CPU0的指令执行阶段</a></p></li>
<li><p><a class="reference internal" href="#id27" id="id89">CPU0的中断向量</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#llvm-structure-llvm" id="id90">LLVM Structure（译者：本节是llvm一些基础介绍，熟悉的同学可以直接跳过）</a></p>
<ul>
<li><p><a class="reference internal" href="#three-phase-design" id="id91">Three-phase design</a></p></li>
<li><p><a class="reference internal" href="#llvm-s-target-description-files-td" id="id92">LLVM’s Target Description Files: .td</a></p></li>
<li><p><a class="reference internal" href="#llvm-code-generation-sequence" id="id93">LLVM Code Generation Sequence</a></p></li>
<li><p><a class="reference internal" href="#ssa-form" id="id94">SSA form</a></p></li>
<li><p><a class="reference internal" href="#dsa-form" id="id95">DSA form</a></p></li>
<li><p><a class="reference internal" href="#llvm-vs-gcc-in-structure" id="id96">LLVM vs GCC in structure</a></p></li>
<li><p><a class="reference internal" href="#llvm-blog" id="id97">LLVM blog</a></p></li>
<li><p><a class="reference internal" href="#cfg-control-flow-graph" id="id98">CFG (Control Flow Graph)</a></p></li>
<li><p><a class="reference internal" href="#dag-directed-acyclic-graph" id="id99">DAG (Directed Acyclic Graph)</a></p></li>
<li><p><a class="reference internal" href="#instruction-selection" id="id100">Instruction Selection</a></p></li>
<li><p><a class="reference internal" href="#caller-and-callee-saved-registers" id="id101">Caller and callee saved registers</a></p></li>
<li><p><a class="reference internal" href="#live-in-and-live-out-register" id="id102">Live in and live out register</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id47" id="id103">创建Cpu0后端</a></p>
<ul>
<li><p><a class="reference internal" href="#cpu0-id" id="id104">CPU0 后端机器 ID 和重定位记录</a></p></li>
<li><p><a class="reference internal" href="#cpu0-td" id="id105">创建初始的 Cpu0 .td 文件</a></p></li>
<li><p><a class="reference internal" href="#cmake" id="id106">编写 cmake 文件</a></p></li>
<li><p><a class="reference internal" href="#target-registration" id="id107">Target Registration</a></p></li>
<li><p><a class="reference internal" href="#build-libraries-and-td" id="id108">Build libraries and td</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#options-of-llc-for-debug" id="id109">Options of llc for debug</a></p></li>
<li><p><a class="reference internal" href="#options-of-opt" id="id110">Options of opt</a></p></li>
</ul>
</nav>
<p class="linemarker linemarker-10">在开始本教程之前，您应该知道，您始终可以尝试通过移植现有后端的代码来开发自己的后端。
您希望调查的大部分代码可以在您的根 LLVM 安装的 /lib/Target 目录中找到。
由于大多数主要的 RISC 指令集都有一些相似之处，如果您是经验丰富的程序员并且熟悉编译器后端，
这可能是您可以尝试的途径。</p>
<p class="linemarker linemarker-15">另一方面，学习曲线陡峭，你可能会轻易陷入调试新后端的困境。
你可能会花费大量时间去追踪哪些方法是某个函数的回调，
或者是调用了LLVM代码库中某个被覆盖的方法 - 而且在像LLVM这样庞大的代码库中，
所有这些都很容易变得难以跟踪。本教程将帮助你通过学习LLVM后端设计的基础知识来解决这个过程。
它将向你展示让你的第一个后端功能齐全的必要步骤，
并且应该帮助你理解当后端产生错误的机器代码时如何使用编译器提供的输出来调试你的后端</p>
<p class="linemarker linemarker-22">本章详细介绍了Cpu0指令集和LLVM的结构。LLVM结构信息参考自克里斯·拉特纳在《开源应用架构》
一书中的LLVM章节 <a class="footnote-reference brackets" href="#aosa-book" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>。如果你愿意，你可以从AOSA网站上阅读原文。</p>
<p class="linemarker linemarker-25">在本章末尾，您将开始通过在目标描述文件中编写寄存器和指令定义来创建一个新的LLVM后端，
该后端将在下一章中使用。</p>
<p class="linemarker linemarker-28">最后，llvm后端设计需要编译器知识，例如DAG（有向无环图）和指令选择，并且它们在这里进行了解释。</p>
<section id="cpu0">
<h2><a class="toc-backref" href="#id83" role="doc-backlink">CPU0 处理器架构细节</a><a class="headerlink" href="#cpu0" title="Link to this heading"></a></h2>
<p class="linemarker linemarker-33">这一部分基于这里提供的材料 [#cpu0-chinese]_（中文）和这里 [#cpu0-english]_（英文）。
然而，我改变了原始的 Cpu0 中的一些 ISA，用于设计一个简单的整数操作 CPU 和 llvm 后端。
我写这本书的目的是想了解一个简单而机械化的 CPU ISA 和 llvm 后端可以是什么样子。</p>
<section id="id3">
<h3><a class="toc-backref" href="#id84" role="doc-backlink">概要介绍</a><a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-40">Cpu0 is a 32-bit architecture. It has 16 general purpose registers (R0, …,
R15), co-processor registers (like Mips), and other special registers. Its
structure is illustrated in <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f1</span></code> below.</p>
<p class="linemarker linemarker-44">Cpu0 是一个32位架构。它有16个通用寄存器（R0，…，R15），协处理器寄存器（类似于Mips），
以及其他特殊寄存器。它的结构如下图 :numref:<a href="#id4"><span class="problematic" id="id5">`</span></a>llvmstructure-f1`所示。</p>
<figure class="align-center" id="id59">
<span id="llvmstructure-f1"></span><a class="reference internal image-reference" href="_images/1.png"><img alt="_images/1.png" src="_images/1.png" style="width: 608px; height: 360px;" /></a>
<figcaption>
<p><span class="caption-text">Architectural block diagram of the Cpu0 processor</span><a class="headerlink" href="#id59" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-57">寄存器用于于以下目的：</p>
<table class="docutils align-default" id="id60">
<caption><span class="caption-text">Cpu0 general purpose registers (GPR)</span><a class="headerlink" href="#id60" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-62">Register</p></th>
<th class="head"><p class="linemarker linemarker-62">Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-64">R0</p></td>
<td><p class="linemarker linemarker-64">Constant register, value is 0</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-65">R1-R10</p></td>
<td><p class="linemarker linemarker-65">General-purpose registers</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-66">R11</p></td>
<td><p class="linemarker linemarker-66">Global Pointer register (GP)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-67">R12</p></td>
<td><p class="linemarker linemarker-67">Frame Pointer register (FP)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-68">R13</p></td>
<td><p class="linemarker linemarker-68">Stack Pointer register (SP)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-69">R14</p></td>
<td><p class="linemarker linemarker-69">Link Register (LR)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-70">R15</p></td>
<td><p class="linemarker linemarker-70">Status Word Register (SW)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id61">
<caption><span class="caption-text">Cpu0 co-processor 0 registers (C0R)</span><a class="headerlink" href="#id61" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-76">Register</p></th>
<th class="head"><p class="linemarker linemarker-76">Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-78">0</p></td>
<td><p class="linemarker linemarker-78">Program Counter (PC)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-79">1</p></td>
<td><p class="linemarker linemarker-79">Error Program Counter (EPC)</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id62">
<caption><span class="caption-text">Cpu0 other registers</span><a class="headerlink" href="#id62" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-85">Register</p></th>
<th class="head"><p class="linemarker linemarker-85">Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-87">IR</p></td>
<td><p class="linemarker linemarker-87">Instruction register</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-88">MAR</p></td>
<td><p class="linemarker linemarker-88">Memory Address Register (MAR)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-89">MDR</p></td>
<td><p class="linemarker linemarker-89">Memory Data Register (MDR)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-90">HI</p></td>
<td><p class="linemarker linemarker-90">High part of MULT result</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-91">LO</p></td>
<td><p class="linemarker linemarker-91">Low part of MULT result</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id6">
<h3><a class="toc-backref" href="#id85" role="doc-backlink">Cpu0 指令集</a><a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-97">The Cpu0 instruction set can be divided into three types: L-type instructions,
which are generally associated with memory operations, A-type instructions for
arithmetic operations, and J-type instructions that are typically used when
altering control flow (i.e. jumps).
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f2</span></code> illustrates how the bitfields are broken down
for each type of instruction.</p>
<p class="linemarker linemarker-104">CPU0指令集可分为三种类型：L型指令通常与内存操作相关，A型指令用于算术运算，
J型指令通常在更改控制流程时使用（即跳转）。 :numref:<a href="#id7"><span class="problematic" id="id8">`</span></a>llvmstructure-f2`说明了每种指令类型的位域如何分解。</p>
<figure class="align-center" id="id63">
<span id="llvmstructure-f2"></span><a class="reference internal image-reference" href="_images/2.png"><img alt="_images/2.png" src="_images/2.png" style="width: 601px; height: 331px;" /></a>
<figcaption>
<p><span class="caption-text">Cpu0’s three instruction formats</span><a class="headerlink" href="#id63" title="Link to this image"></a></p>
</figcaption>
</figure>
<table class="docutils align-default" id="id64">
<caption><span class="caption-text">C, llvm-ir <a class="footnote-reference brackets" href="#langref" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> and Cpu0</span><a class="headerlink" href="#id64" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-122">C</p></th>
<th class="head"><p class="linemarker linemarker-122">llvm-ir</p></th>
<th class="head"><p class="linemarker linemarker-122">Cpu0</p></th>
<th class="head"><p class="linemarker linemarker-122">I or II</p></th>
<th class="head"><p class="linemarker linemarker-122">Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-124">=</p></td>
<td><p class="linemarker linemarker-124">load/store</p></td>
<td><p class="linemarker linemarker-124">ld/lb/lbu/lh/lhu</p></td>
<td><p class="linemarker linemarker-124">I</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-125">&amp;, &amp;&amp;</p></td>
<td><p class="linemarker linemarker-125">and</p></td>
<td><p class="linemarker linemarker-125">and</p></td>
<td><p class="linemarker linemarker-125">I</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-126">|, ||</p></td>
<td><p class="linemarker linemarker-126">or</p></td>
<td><p class="linemarker linemarker-126">or</p></td>
<td><p class="linemarker linemarker-126">I</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-127">^</p></td>
<td><p class="linemarker linemarker-127">xor</p></td>
<td><p class="linemarker linemarker-127">xor/nor</p></td>
<td><p class="linemarker linemarker-127">I</p></td>
<td><p class="linemarker linemarker-127">! can be got from two ir</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-128">!</p></td>
<td><ul class="simple">
<li><p class="linemarker linemarker-128">%tobool = icmp ne i32 %6, 0</p></li>
<li><p class="linemarker linemarker-129">%lnot = xor i1 %tobool, true</p></li>
</ul>
</td>
<td><ul class="simple">
<li><p class="linemarker linemarker-128">cmp</p></li>
<li><p class="linemarker linemarker-129">xor</p></li>
</ul>
</td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-130">==, !=, &lt;, &lt;=, &gt;, &gt;=</p></td>
<td><p class="linemarker linemarker-130">icmp/fcmp &lt;cond&gt; cond:eq/ne,…</p></td>
<td><p class="linemarker linemarker-130">cmp/ucmp … + floating-lib</p></td>
<td><p class="linemarker linemarker-130">I</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-131">“</p></td>
<td><p class="linemarker linemarker-131">“</p></td>
<td><p class="linemarker linemarker-131">slt/sltu/slti/sltiu</p></td>
<td><p class="linemarker linemarker-131">II</p></td>
<td><p class="linemarker linemarker-131">slti/sltiu: ex. a == 3 reduce instructions</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-132">if (a &lt;= b)</p></td>
<td><p class="linemarker linemarker-132">icmp/fcmp &lt;cond&gt; +
br i1 &lt;cond&gt;, …</p></td>
<td><p class="linemarker linemarker-132">cmp/uccmp + jeq/jne/jlt/jgt/jle/jge</p></td>
<td><p class="linemarker linemarker-132">I</p></td>
<td><p class="linemarker linemarker-132">Conditional branch</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-134">if (bool)</p></td>
<td><p class="linemarker linemarker-134">br i1 &lt;cond&gt;, …</p></td>
<td><p class="linemarker linemarker-134">jeq/jne</p></td>
<td><p class="linemarker linemarker-134">I</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-135">“</p></td>
<td><p class="linemarker linemarker-135">“</p></td>
<td><p class="linemarker linemarker-135">beq/bne</p></td>
<td><p class="linemarker linemarker-135">II</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-136">goto</p></td>
<td><p class="linemarker linemarker-136">br &lt;dest&gt;</p></td>
<td><p class="linemarker linemarker-136">jmp</p></td>
<td><p class="linemarker linemarker-136">I</p></td>
<td><p class="linemarker linemarker-136">Uncondictional branch</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-137">call sub-function</p></td>
<td><p class="linemarker linemarker-137">call</p></td>
<td><p class="linemarker linemarker-137">jsub</p></td>
<td><p class="linemarker linemarker-137">I</p></td>
<td><p class="linemarker linemarker-137">Provide 24-bit address range of calling sub-function (the address from caller to callee is within 24-bit)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-138">“</p></td>
<td><p class="linemarker linemarker-138">“</p></td>
<td><p class="linemarker linemarker-138">jalr</p></td>
<td><p class="linemarker linemarker-138">I</p></td>
<td><p class="linemarker linemarker-138">Add for 32-bit address range of calling sub-function</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-139">return</p></td>
<td><p class="linemarker linemarker-139">ret</p></td>
<td><p class="linemarker linemarker-139">ret</p></td>
<td><p class="linemarker linemarker-139">I</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-140">+, -, *</p></td>
<td><p class="linemarker linemarker-140">add/fadd, sub/fsub, mul/fmul</p></td>
<td><p class="linemarker linemarker-140">add/addu/addiu, sub/subu, mul</p></td>
<td><p class="linemarker linemarker-140">I</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-141">/, %</p></td>
<td><p class="linemarker linemarker-141">udiv/sdiv/fdiv, urem/srem/frem</p></td>
<td><p class="linemarker linemarker-141">div, mfhi/mflo/mthi/mtlo</p></td>
<td><p class="linemarker linemarker-141">I</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-142">&lt;&lt;, &gt;&gt;</p></td>
<td><p class="linemarker linemarker-142">shl, lshr/ashr</p></td>
<td><p class="linemarker linemarker-142">shl/rol/rolv, srl/sra/ror/rorv</p></td>
<td><p class="linemarker linemarker-142">II</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-143">float &lt;-&gt; int</p></td>
<td><p class="linemarker linemarker-143">fptoui, sitofp, …</p></td>
<td></td>
<td></td>
<td><p class="linemarker linemarker-143">Cpu0 uses SW for floating value, and these two IR are for HW floating instruction</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-144">__builtin_clz/clo</p></td>
<td><p class="linemarker linemarker-144">llvm.clz/llvm_clo</p></td>
<td><p class="linemarker linemarker-144">floating-lib + clz, clo</p></td>
<td><p class="linemarker linemarker-144">I</p></td>
<td><p class="linemarker linemarker-144">For SW floating-lib, uses __builtin_clz / __builtin_clo in clang and clang generates llvm.clz/llvm.clo intrinsic function</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-145">__builtin_eh_xxx</p></td>
<td><p class="linemarker linemarker-145">llvm.eh.xxx</p></td>
<td><p class="linemarker linemarker-145">st/ld</p></td>
<td><p class="linemarker linemarker-145">I</p></td>
<td><p class="linemarker linemarker-145">pass information to exception handler through $4, $5</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id65">
<caption><span class="caption-text">C++, llvm-ir <a class="footnote-reference brackets" href="#langref" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> and Cpu0</span><a class="headerlink" href="#id65" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-151">C++</p></th>
<th class="head"><p class="linemarker linemarker-151">llvm-ir</p></th>
<th class="head"><p class="linemarker linemarker-151">Cpu0</p></th>
<th class="head"><p class="linemarker linemarker-151">I or II</p></th>
<th class="head"><p class="linemarker linemarker-151">Comment</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-153">try {  }</p></td>
<td><p class="linemarker linemarker-153">invoke void &#64;_Z15throw_exception</p></td>
<td><p class="linemarker linemarker-153">jsub  _Z15throw_exception</p></td>
<td><p class="linemarker linemarker-153">I</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-154">catch { }</p></td>
<td><p class="linemarker linemarker-154">landingpad…catch</p></td>
<td><p class="linemarker linemarker-154">st and ld</p></td>
<td><p class="linemarker linemarker-154">I</p></td>
<td><p class="linemarker linemarker-154">st/ld $4 &amp; $5 to/from stack, $4:exception address, $5: exception typeid</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="linemarker linemarker-157"><strong>如何区别 RISC CPU 的 LLVM IR 和指令集？</strong></p>
<ul class="simple">
<li><p class="linemarker linemarker-159">RISC CPU 的 LLVM-IR 和指令集在 C 语言之后出现。如上表所示，它们可以基于 C 语言进行区别。</p></li>
<li><p class="linemarker linemarker-161">以上表格中未列出的内容，LLVM-IR 包括终结指令“switch, invoke, …”，原子操作以及许多 LLVM 内部函数，以提供更好的性能给后端，以适配它们的特定指令，
如 llvm.vector.reduce.*。</p></li>
<li><p class="linemarker linemarker-164">对于 CPU/GPU 的矢量处理，它们可以使用矢量类型的 LLVM-IR 或 LLVM 内部函数来实现。</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="linemarker linemarker-167"><strong>Cpu0 的ISA是如何选择的</strong></p>
<ul class="simple">
<li><p class="linemarker linemarker-169">CPU0的原始作者意图：设计ISA供教材使用，而不考虑性能。</p></li>
<li><p class="linemarker linemarker-171">我的目标意图：添加一个目标，即考虑到ISA既可以作为LLVM简单教程材料被选择或设计，</p></li>
<li><p class="linemarker linemarker-172">也可以作为ISA的基本性能。我对糟糕的ISA不感兴趣。</p>
<ul>
<li><p class="linemarker linemarker-174">从上表中可以看出，“if (a &lt;= b)”可以替换为“t = (a &lt;= b)”和“if (t)”，因此我设计了Cpu0的ISA II“slt+beq”来替换“cmp+jeq”，将jeq/jne/jlt/jgt/jle/jge六条指令减少到两条，以在Cpu0 ISA和性能中平衡复杂性。</p></li>
<li><p class="linemarker linemarker-176">由于同样的原因，我选择来自 <strong>Mips**的 **slt</strong> 而不是 <strong>ARM**的 **cmp</strong>，
结果是目标寄存器可以是任何通用寄存器，以避免在同一“状态寄存器”上出现瓶颈。</p></li>
<li><p class="linemarker linemarker-179">浮点值可以通过软件实现，因此 Cpu0 只有整数指令。
我将 clz 和 clo 添加到 Cpu0 中，因为像 compiler-rt/builtin 这样的浮点库是在这两个内建函数的基础上实现的。浮点精度的规范化可以使用 clz 和 clo 来加速。虽然 Cpu0 可以使用几个指令来处理对应的 llvm.clz/llvm.clo，但添加 clz/clo 可以在单个指令中执行它。</p></li>
<li><p class="linemarker linemarker-182">根据以上的理由，我将 Cpu0 的 II 扩展为 Mips 中性能更好的 ISA。</p></li>
</ul>
</li>
</ul>
</div>
<p class="linemarker linemarker-184">以下表格详细介绍了cpu032I指令集：</p>
<ul class="simple">
<li><p class="linemarker linemarker-186">First column F.: meaning Format.</p></li>
</ul>
<table class="docutils align-default" id="id66">
<caption><span class="caption-text">cpu032I Instruction Set</span><a class="headerlink" href="#id66" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 2.8%" />
<col style="width: 11.1%" />
<col style="width: 8.3%" />
<col style="width: 30.6%" />
<col style="width: 19.4%" />
<col style="width: 27.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-192">F.</p></th>
<th class="head"><p class="linemarker linemarker-193">Mnemonic</p></th>
<th class="head"><p class="linemarker linemarker-194">Opcode</p></th>
<th class="head"><p class="linemarker linemarker-195">Meaning</p></th>
<th class="head"><p class="linemarker linemarker-196">Syntax</p></th>
<th class="head"><p class="linemarker linemarker-197">Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-198">L</p></td>
<td><p class="linemarker linemarker-199">NOP</p></td>
<td><p class="linemarker linemarker-200">00</p></td>
<td><p class="linemarker linemarker-201">No Operation</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-204">L</p></td>
<td><p class="linemarker linemarker-205">LD</p></td>
<td><p class="linemarker linemarker-206">01</p></td>
<td><p class="linemarker linemarker-207">Load word</p></td>
<td><p class="linemarker linemarker-208">LD Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-209">Ra &lt;= [Rb+Cx]</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-210">L</p></td>
<td><p class="linemarker linemarker-211">ST</p></td>
<td><p class="linemarker linemarker-212">02</p></td>
<td><p class="linemarker linemarker-213">Store word</p></td>
<td><p class="linemarker linemarker-214">ST Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-215">[Rb+Cx] &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-216">L</p></td>
<td><p class="linemarker linemarker-217">LB</p></td>
<td><p class="linemarker linemarker-218">03</p></td>
<td><p class="linemarker linemarker-219">Load byte</p></td>
<td><p class="linemarker linemarker-220">LB Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-221">Ra &lt;= (byte)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-222">L</p></td>
<td><p class="linemarker linemarker-223">LBu</p></td>
<td><p class="linemarker linemarker-224">04</p></td>
<td><p class="linemarker linemarker-225">Load byte unsigned</p></td>
<td><p class="linemarker linemarker-226">LBu Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-227">Ra &lt;= (byte)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-228">L</p></td>
<td><p class="linemarker linemarker-229">SB</p></td>
<td><p class="linemarker linemarker-230">05</p></td>
<td><p class="linemarker linemarker-231">Store byte</p></td>
<td><p class="linemarker linemarker-232">SB Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-233">[Rb+Cx] &lt;= (byte)Ra</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-234">L</p></td>
<td><p class="linemarker linemarker-235">LH</p></td>
<td><p class="linemarker linemarker-236">06</p></td>
<td><p class="linemarker linemarker-237">Load half word</p></td>
<td><p class="linemarker linemarker-238">LH Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-239">Ra &lt;= (2bytes)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-240">L</p></td>
<td><p class="linemarker linemarker-241">LHu</p></td>
<td><p class="linemarker linemarker-242">07</p></td>
<td><p class="linemarker linemarker-243">Load half word unsigned</p></td>
<td><p class="linemarker linemarker-244">LHu Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-245">Ra &lt;= (2bytes)[Rb+Cx] <a class="footnote-reference brackets" href="#lb-note" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-246">L</p></td>
<td><p class="linemarker linemarker-247">SH</p></td>
<td><p class="linemarker linemarker-248">08</p></td>
<td><p class="linemarker linemarker-249">Store half word</p></td>
<td><p class="linemarker linemarker-250">SH Ra, [Rb+Cx]</p></td>
<td><p class="linemarker linemarker-251">[Rb+Cx] &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-252">L</p></td>
<td><p class="linemarker linemarker-253">ADDiu</p></td>
<td><p class="linemarker linemarker-254">09</p></td>
<td><p class="linemarker linemarker-255">Add immediate</p></td>
<td><p class="linemarker linemarker-256">ADDiu Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-257">Ra &lt;= (Rb + Cx)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-258">L</p></td>
<td><p class="linemarker linemarker-259">ANDi</p></td>
<td><p class="linemarker linemarker-260">0C</p></td>
<td><p class="linemarker linemarker-261">AND imm</p></td>
<td><p class="linemarker linemarker-262">ANDi Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-263">Ra &lt;= (Rb &amp; Cx)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-264">L</p></td>
<td><p class="linemarker linemarker-265">ORi</p></td>
<td><p class="linemarker linemarker-266">0D</p></td>
<td><p class="linemarker linemarker-267">OR</p></td>
<td><p class="linemarker linemarker-268">ORi Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-269">Ra &lt;= (Rb | Cx)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-270">L</p></td>
<td><p class="linemarker linemarker-271">XORi</p></td>
<td><p class="linemarker linemarker-272">0E</p></td>
<td><p class="linemarker linemarker-273">XOR</p></td>
<td><p class="linemarker linemarker-274">XORi Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-275">Ra &lt;= (Rb ^ Cx)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-276">L</p></td>
<td><p class="linemarker linemarker-277">LUi</p></td>
<td><p class="linemarker linemarker-278">0F</p></td>
<td><p class="linemarker linemarker-279">Load upper</p></td>
<td><p class="linemarker linemarker-280">LUi Ra, Cx</p></td>
<td><p class="linemarker linemarker-281">Ra &lt;= (Cx &lt;&lt; 16)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-282">A</p></td>
<td><p class="linemarker linemarker-283">ADDu</p></td>
<td><p class="linemarker linemarker-284">11</p></td>
<td><p class="linemarker linemarker-285">Add unsigned</p></td>
<td><p class="linemarker linemarker-286">ADD Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-287">Ra &lt;= Rb + Rc <a class="footnote-reference brackets" href="#u-note" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-288">A</p></td>
<td><p class="linemarker linemarker-289">SUBu</p></td>
<td><p class="linemarker linemarker-290">12</p></td>
<td><p class="linemarker linemarker-291">Sub unsigned</p></td>
<td><p class="linemarker linemarker-292">SUB Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-293">Ra &lt;= Rb - Rc <a class="footnote-reference brackets" href="#u-note" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-294">A</p></td>
<td><p class="linemarker linemarker-295">ADD</p></td>
<td><p class="linemarker linemarker-296">13</p></td>
<td><p class="linemarker linemarker-297">Add</p></td>
<td><p class="linemarker linemarker-298">ADD Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-299">Ra &lt;= Rb + Rc <a class="footnote-reference brackets" href="#u-note" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-300">A</p></td>
<td><p class="linemarker linemarker-301">SUB</p></td>
<td><p class="linemarker linemarker-302">14</p></td>
<td><p class="linemarker linemarker-303">Subtract</p></td>
<td><p class="linemarker linemarker-304">SUB Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-305">Ra &lt;= Rb - Rc <a class="footnote-reference brackets" href="#u-note" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-306">A</p></td>
<td><p class="linemarker linemarker-307">CLZ</p></td>
<td><p class="linemarker linemarker-308">15</p></td>
<td><p class="linemarker linemarker-309">Count Leading Zero</p></td>
<td><p class="linemarker linemarker-310">CLZ Ra, Rb</p></td>
<td><p class="linemarker linemarker-311">Ra &lt;= bits of leading zero on Rb</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-312">A</p></td>
<td><p class="linemarker linemarker-313">CLO</p></td>
<td><p class="linemarker linemarker-314">16</p></td>
<td><p class="linemarker linemarker-315">Count Leading One</p></td>
<td><p class="linemarker linemarker-316">CLO Ra, Rb</p></td>
<td><p class="linemarker linemarker-317">Ra &lt;= bits of leading one on Rb</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-318">A</p></td>
<td><p class="linemarker linemarker-319">MUL</p></td>
<td><p class="linemarker linemarker-320">17</p></td>
<td><p class="linemarker linemarker-321">Multiply</p></td>
<td><p class="linemarker linemarker-322">MUL Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-323">Ra &lt;= Rb * Rc</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-324">A</p></td>
<td><p class="linemarker linemarker-325">AND</p></td>
<td><p class="linemarker linemarker-326">18</p></td>
<td><p class="linemarker linemarker-327">Bitwise and</p></td>
<td><p class="linemarker linemarker-328">AND Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-329">Ra &lt;= Rb &amp; Rc</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-330">A</p></td>
<td><p class="linemarker linemarker-331">OR</p></td>
<td><p class="linemarker linemarker-332">19</p></td>
<td><p class="linemarker linemarker-333">Bitwise or</p></td>
<td><p class="linemarker linemarker-334">OR Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-335">Ra &lt;= Rb | Rc</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-336">A</p></td>
<td><p class="linemarker linemarker-337">XOR</p></td>
<td><p class="linemarker linemarker-338">1A</p></td>
<td><p class="linemarker linemarker-339">Bitwise exclusive or</p></td>
<td><p class="linemarker linemarker-340">XOR Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-341">Ra &lt;= Rb ^ Rc</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-342">A</p></td>
<td><p class="linemarker linemarker-343">NOR</p></td>
<td><p class="linemarker linemarker-344">1B</p></td>
<td><p class="linemarker linemarker-345">Bitwise boolean nor</p></td>
<td><p class="linemarker linemarker-346">NOR Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-347">Ra &lt;= Rb nor Rc</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-348">A</p></td>
<td><p class="linemarker linemarker-349">ROL</p></td>
<td><p class="linemarker linemarker-350">1C</p></td>
<td><p class="linemarker linemarker-351">Rotate left</p></td>
<td><p class="linemarker linemarker-352">ROL Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-353">Ra &lt;= Rb rol Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-354">A</p></td>
<td><p class="linemarker linemarker-355">ROR</p></td>
<td><p class="linemarker linemarker-356">1D</p></td>
<td><p class="linemarker linemarker-357">Rotate right</p></td>
<td><p class="linemarker linemarker-358">ROR Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-359">Ra &lt;= Rb ror Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-360">A</p></td>
<td><p class="linemarker linemarker-361">SHL</p></td>
<td><p class="linemarker linemarker-362">1E</p></td>
<td><p class="linemarker linemarker-363">Shift left</p></td>
<td><p class="linemarker linemarker-364">SHL Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-365">Ra &lt;= Rb &lt;&lt; Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-366">A</p></td>
<td><p class="linemarker linemarker-367">SHR</p></td>
<td><p class="linemarker linemarker-368">1F</p></td>
<td><p class="linemarker linemarker-369">Shift right</p></td>
<td><p class="linemarker linemarker-370">SHR Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-371">Ra &lt;= Rb &gt;&gt; Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-372">A</p></td>
<td><p class="linemarker linemarker-373">SRA</p></td>
<td><p class="linemarker linemarker-374">20</p></td>
<td><p class="linemarker linemarker-375">Shift right</p></td>
<td><p class="linemarker linemarker-376">SRA Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-377">Ra &lt;= Rb ‘&gt;&gt; Cx <a class="footnote-reference brackets" href="#sra-note" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-378">A</p></td>
<td><p class="linemarker linemarker-379">SRAV</p></td>
<td><p class="linemarker linemarker-380">21</p></td>
<td><p class="linemarker linemarker-381">Shift right</p></td>
<td><p class="linemarker linemarker-382">SRAV Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-383">Ra &lt;= Rb ‘&gt;&gt; Rc <a class="footnote-reference brackets" href="#sra-note" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-384">A</p></td>
<td><p class="linemarker linemarker-385">SHLV</p></td>
<td><p class="linemarker linemarker-386">22</p></td>
<td><p class="linemarker linemarker-387">Shift left</p></td>
<td><p class="linemarker linemarker-388">SHLV Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-389">Ra &lt;= Rb &lt;&lt; Rc</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-390">A</p></td>
<td><p class="linemarker linemarker-391">SHRV</p></td>
<td><p class="linemarker linemarker-392">23</p></td>
<td><p class="linemarker linemarker-393">Shift right</p></td>
<td><p class="linemarker linemarker-394">SHRV Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-395">Ra &lt;= Rb &gt;&gt; Rc</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-396">A</p></td>
<td><p class="linemarker linemarker-397">ROL</p></td>
<td><p class="linemarker linemarker-398">24</p></td>
<td><p class="linemarker linemarker-399">Rotate left</p></td>
<td><p class="linemarker linemarker-400">ROL Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-401">Ra &lt;= Rb rol Rc</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-402">A</p></td>
<td><p class="linemarker linemarker-403">ROR</p></td>
<td><p class="linemarker linemarker-404">25</p></td>
<td><p class="linemarker linemarker-405">Rotate right</p></td>
<td><p class="linemarker linemarker-406">ROR Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-407">Ra &lt;= Rb ror Rc</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-408">A</p></td>
<td><p class="linemarker linemarker-409">CMP</p></td>
<td><p class="linemarker linemarker-410">2A</p></td>
<td><p class="linemarker linemarker-411">Compare</p></td>
<td><p class="linemarker linemarker-412">CMP Ra, Rb</p></td>
<td><p class="linemarker linemarker-413">SW &lt;= (Ra cond Rb) <a class="footnote-reference brackets" href="#cond-note" id="id21" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-414">A</p></td>
<td><p class="linemarker linemarker-415">CMPu</p></td>
<td><p class="linemarker linemarker-416">2B</p></td>
<td><p class="linemarker linemarker-417">Compare</p></td>
<td><p class="linemarker linemarker-418">CMPu Ra, Rb</p></td>
<td><p class="linemarker linemarker-419">SW &lt;= (Ra cond Rb) <a class="footnote-reference brackets" href="#cond-note" id="id22" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-420">J</p></td>
<td><p class="linemarker linemarker-421">JEQ</p></td>
<td><p class="linemarker linemarker-422">30</p></td>
<td><p class="linemarker linemarker-423">Jump if equal (==)</p></td>
<td><p class="linemarker linemarker-424">JEQ Cx</p></td>
<td><p class="linemarker linemarker-425">if SW(==), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-426">J</p></td>
<td><p class="linemarker linemarker-427">JNE</p></td>
<td><p class="linemarker linemarker-428">31</p></td>
<td><p class="linemarker linemarker-429">Jump if not equal (!=)</p></td>
<td><p class="linemarker linemarker-430">JNE Cx</p></td>
<td><p class="linemarker linemarker-431">if SW(!=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-432">J</p></td>
<td><p class="linemarker linemarker-433">JLT</p></td>
<td><p class="linemarker linemarker-434">32</p></td>
<td><p class="linemarker linemarker-435">Jump if less than (&lt;)</p></td>
<td><p class="linemarker linemarker-436">JLT Cx</p></td>
<td><p class="linemarker linemarker-437">if SW(&lt;), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-438">J</p></td>
<td><p class="linemarker linemarker-439">JGT</p></td>
<td><p class="linemarker linemarker-440">33</p></td>
<td><p class="linemarker linemarker-441">Jump if greater than (&gt;)</p></td>
<td><p class="linemarker linemarker-442">JGT Cx</p></td>
<td><p class="linemarker linemarker-443">if SW(&gt;), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-444">J</p></td>
<td><p class="linemarker linemarker-445">JLE</p></td>
<td><p class="linemarker linemarker-446">34</p></td>
<td><p class="linemarker linemarker-447">Jump if less than or equals (&lt;=)</p></td>
<td><p class="linemarker linemarker-448">JLE Cx</p></td>
<td><p class="linemarker linemarker-449">if SW(&lt;=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-450">J</p></td>
<td><p class="linemarker linemarker-451">JGE</p></td>
<td><p class="linemarker linemarker-452">35</p></td>
<td><p class="linemarker linemarker-453">Jump if greater than or equals (&gt;=)</p></td>
<td><p class="linemarker linemarker-454">JGE Cx</p></td>
<td><p class="linemarker linemarker-455">if SW(&gt;=), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-456">J</p></td>
<td><p class="linemarker linemarker-457">JMP</p></td>
<td><p class="linemarker linemarker-458">36</p></td>
<td><p class="linemarker linemarker-459">Jump (unconditional)</p></td>
<td><p class="linemarker linemarker-460">JMP Cx</p></td>
<td><p class="linemarker linemarker-461">PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-462">J</p></td>
<td><p class="linemarker linemarker-463">JALR</p></td>
<td><p class="linemarker linemarker-464">39</p></td>
<td><p class="linemarker linemarker-465">Indirect jump</p></td>
<td><p class="linemarker linemarker-466">JALR Rb</p></td>
<td><p class="linemarker linemarker-467">LR &lt;= PC; PC &lt;= Rb <a class="footnote-reference brackets" href="#call-note" id="id23" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-468">J</p></td>
<td><p class="linemarker linemarker-469">BAL</p></td>
<td><p class="linemarker linemarker-470">3A</p></td>
<td><p class="linemarker linemarker-471">Branch and link</p></td>
<td><p class="linemarker linemarker-472">BAL Cx</p></td>
<td><p class="linemarker linemarker-473">LR &lt;= PC; PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-474">J</p></td>
<td><p class="linemarker linemarker-475">JSUB</p></td>
<td><p class="linemarker linemarker-476">3B</p></td>
<td><p class="linemarker linemarker-477">Jump to subroutine</p></td>
<td><p class="linemarker linemarker-478">JSUB Cx</p></td>
<td><p class="linemarker linemarker-479">LR &lt;= PC; PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-480">J</p></td>
<td><p class="linemarker linemarker-481">JR/RET</p></td>
<td><p class="linemarker linemarker-482">3C</p></td>
<td><p class="linemarker linemarker-483">Return from subroutine</p></td>
<td><p class="linemarker linemarker-484">JR $1 or RET LR</p></td>
<td><p class="linemarker linemarker-485">PC &lt;= LR <a class="footnote-reference brackets" href="#jr-note" id="id24" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-486">A</p></td>
<td><p class="linemarker linemarker-487">MULT</p></td>
<td><p class="linemarker linemarker-488">41</p></td>
<td><p class="linemarker linemarker-489">Multiply for 64 bits result</p></td>
<td><p class="linemarker linemarker-490">MULT Ra, Rb</p></td>
<td><p class="linemarker linemarker-491">(HI,LO) &lt;= MULT(Ra,Rb)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-492">A</p></td>
<td><p class="linemarker linemarker-493">MULTU</p></td>
<td><p class="linemarker linemarker-494">42</p></td>
<td><p class="linemarker linemarker-495">MULT for unsigned 64 bits</p></td>
<td><p class="linemarker linemarker-496">MULTU Ra, Rb</p></td>
<td><p class="linemarker linemarker-497">(HI,LO) &lt;= MULTU(Ra,Rb)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-498">A</p></td>
<td><p class="linemarker linemarker-499">DIV</p></td>
<td><p class="linemarker linemarker-500">43</p></td>
<td><p class="linemarker linemarker-501">Divide</p></td>
<td><p class="linemarker linemarker-502">DIV Ra, Rb</p></td>
<td><p class="linemarker linemarker-503">HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-504">A</p></td>
<td><p class="linemarker linemarker-505">DIVU</p></td>
<td><p class="linemarker linemarker-506">44</p></td>
<td><p class="linemarker linemarker-507">Divide unsigned</p></td>
<td><p class="linemarker linemarker-508">DIVU Ra, Rb</p></td>
<td><p class="linemarker linemarker-509">HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-510">A</p></td>
<td><p class="linemarker linemarker-511">MFHI</p></td>
<td><p class="linemarker linemarker-512">46</p></td>
<td><p class="linemarker linemarker-513">Move HI to GPR</p></td>
<td><p class="linemarker linemarker-514">MFHI Ra</p></td>
<td><p class="linemarker linemarker-515">Ra &lt;= HI</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-516">A</p></td>
<td><p class="linemarker linemarker-517">MFLO</p></td>
<td><p class="linemarker linemarker-518">47</p></td>
<td><p class="linemarker linemarker-519">Move LO to GPR</p></td>
<td><p class="linemarker linemarker-520">MFLO Ra</p></td>
<td><p class="linemarker linemarker-521">Ra &lt;= LO</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-522">A</p></td>
<td><p class="linemarker linemarker-523">MTHI</p></td>
<td><p class="linemarker linemarker-524">48</p></td>
<td><p class="linemarker linemarker-525">Move GPR to HI</p></td>
<td><p class="linemarker linemarker-526">MTHI Ra</p></td>
<td><p class="linemarker linemarker-527">HI &lt;= Ra</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-528">A</p></td>
<td><p class="linemarker linemarker-529">MTLO</p></td>
<td><p class="linemarker linemarker-530">49</p></td>
<td><p class="linemarker linemarker-531">Move GPR to LO</p></td>
<td><p class="linemarker linemarker-532">MTLO Ra</p></td>
<td><p class="linemarker linemarker-533">LO &lt;= Ra</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-534">A</p></td>
<td><p class="linemarker linemarker-535">MFC0</p></td>
<td><p class="linemarker linemarker-536">50</p></td>
<td><p class="linemarker linemarker-537">Move C0R to GPR</p></td>
<td><p class="linemarker linemarker-538">MFC0 Ra, Rb</p></td>
<td><p class="linemarker linemarker-539">Ra &lt;= Rb</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-540">A</p></td>
<td><p class="linemarker linemarker-541">MTC0</p></td>
<td><p class="linemarker linemarker-542">51</p></td>
<td><p class="linemarker linemarker-543">Move GPR to C0R</p></td>
<td><p class="linemarker linemarker-544">MTC0 Ra, Rb</p></td>
<td><p class="linemarker linemarker-545">Ra &lt;= Rb</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-546">A</p></td>
<td><p class="linemarker linemarker-547">C0MOV</p></td>
<td><p class="linemarker linemarker-548">52</p></td>
<td><p class="linemarker linemarker-549">Move C0R to C0R</p></td>
<td><p class="linemarker linemarker-550">C0MOV Ra, Rb</p></td>
<td><p class="linemarker linemarker-551">Ra &lt;= Rb</p></td>
</tr>
</tbody>
</table>
<p class="linemarker linemarker-554">以下表格详细说明了添加的cpu032II指令集：</p>
<table class="docutils align-default" id="id67">
<caption><span class="caption-text">cpu032II Instruction Set</span><a class="headerlink" href="#id67" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 2.8%" />
<col style="width: 11.1%" />
<col style="width: 8.3%" />
<col style="width: 30.6%" />
<col style="width: 19.4%" />
<col style="width: 27.8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-560">F.</p></th>
<th class="head"><p class="linemarker linemarker-561">Mnemonic</p></th>
<th class="head"><p class="linemarker linemarker-562">Opcode</p></th>
<th class="head"><p class="linemarker linemarker-563">Meaning</p></th>
<th class="head"><p class="linemarker linemarker-564">Syntax</p></th>
<th class="head"><p class="linemarker linemarker-565">Operation</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-566">L</p></td>
<td><p class="linemarker linemarker-567">SLTi</p></td>
<td><p class="linemarker linemarker-568">26</p></td>
<td><p class="linemarker linemarker-569">Set less Then</p></td>
<td><p class="linemarker linemarker-570">SLTi Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-571">Ra &lt;= (Rb &lt; Cx)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-572">L</p></td>
<td><p class="linemarker linemarker-573">SLTiu</p></td>
<td><p class="linemarker linemarker-574">27</p></td>
<td><p class="linemarker linemarker-575">SLTi unsigned</p></td>
<td><p class="linemarker linemarker-576">SLTiu Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-577">Ra &lt;= (Rb &lt; Cx)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-578">A</p></td>
<td><p class="linemarker linemarker-579">SLT</p></td>
<td><p class="linemarker linemarker-580">28</p></td>
<td><p class="linemarker linemarker-581">Set less Then</p></td>
<td><p class="linemarker linemarker-582">SLT Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-583">Ra &lt;= (Rb &lt; Rc)</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-584">A</p></td>
<td><p class="linemarker linemarker-585">SLTu</p></td>
<td><p class="linemarker linemarker-586">29</p></td>
<td><p class="linemarker linemarker-587">SLT unsigned</p></td>
<td><p class="linemarker linemarker-588">SLTu Ra, Rb, Rc</p></td>
<td><p class="linemarker linemarker-589">Ra &lt;= (Rb &lt; Rc)</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-590">L</p></td>
<td><p class="linemarker linemarker-591">BEQ</p></td>
<td><p class="linemarker linemarker-592">37</p></td>
<td><p class="linemarker linemarker-593">Branch if equal</p></td>
<td><p class="linemarker linemarker-594">BEQ Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-595">if (Ra==Rb), PC &lt;= PC + Cx</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-596">L</p></td>
<td><p class="linemarker linemarker-597">BNE</p></td>
<td><p class="linemarker linemarker-598">38</p></td>
<td><p class="linemarker linemarker-599">Branch if not equal</p></td>
<td><p class="linemarker linemarker-600">BNE Ra, Rb, Cx</p></td>
<td><p class="linemarker linemarker-601">if (Ra!=Rb), PC &lt;= PC + Cx</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p class="linemarker linemarker-603"><strong>CPU0 无符号指令</strong></p>
<p class="linemarker linemarker-605">与Mips类似，除了DIVU之外，诸如ADDu和SUBu之类的数学无符号指令，都是没有溢出异常的指令。
ADDu和SUBu可以很好地处理有符号和无符号整数。例如，(ADDu 1, -2)是-1；
(ADDu 0x01, 0xfffffffe)是0xffffffff = (4G - 1)。
如果您将结果视为负数，则为-1。另一方面，如果您将结果视为正数，则为(+4G - 1)。</p>
</div>
<section id="addsub">
<h4><a class="toc-backref" href="#id86" role="doc-backlink">为什么不使用ADD而使用SUB?</a><a class="headerlink" href="#addsub" title="Link to this heading"></a></h4>
<p class="linemarker linemarker-614">根据计算机入门教材，我们知道SUB可以被ADD替换如下：</p>
<ul class="simple">
<li><p class="linemarker linemarker-616">(A - B) = (A + (-B))</p></li>
</ul>
<p class="linemarker linemarker-618">Since Mips uses 32 bits to represent int type of C language, if B is the
value of -2G, then</p>
<ul class="simple">
<li><p class="linemarker linemarker-621">(A - (-2G)) = (A + (2G))</p></li>
</ul>
<p class="linemarker linemarker-623">但问题在于在32位机器中可以表示-2G的值，而不能表示2G的值，
因为32位2的补码表示的范围是(-2G .. 2G-1)。2的补码表示在电路设计中具有快速计算的优点，
因此在真实的CPU实现中被广泛使用。
这就是为什么几乎每个CPU都创建SUB指令，而不是使用ADD。</p>
</section>
</section>
<section id="id25">
<h3><a class="toc-backref" href="#id87" role="doc-backlink">状态寄存器</a><a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-632">Cpu0 状态字寄存器（SW）包含了负数（N）、零（Z）、进位（C）、溢出（V）、调试（D）、模式（M）和
中断（I）标志的状态。
SW 寄存器的位布局如下图所示。</p>
<figure class="align-center" id="id68">
<span id="llvmstructure-f3"></span><a class="reference internal image-reference" href="_images/3.png"><img alt="_images/3.png" src="_images/3.png" style="width: 684px; height: 126px;" /></a>
<figcaption>
<p><span class="caption-text">Cpu0 status word (SW) register</span><a class="headerlink" href="#id68" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-644">当执行 CMP Ra，Rb 指令时，条件标志将会改变。例如：</p>
<ul class="simple">
<li><p class="linemarker linemarker-646">If Ra &gt; Rb, then N = 0, Z = 0</p></li>
<li><p class="linemarker linemarker-647">If Ra &lt; Rb, then N = 1, Z = 0</p></li>
<li><p class="linemarker linemarker-648">If Ra = Rb, then N = 0, Z = 1</p></li>
</ul>
<p class="linemarker linemarker-650">条件跳转指令 JGT、JLT、JGE、JLE、JEQ、JNE 的方向（即执行/不执行）由 SW 寄存器中的 N 和 Z 标志位确定。</p>
</section>
<section id="id26">
<h3><a class="toc-backref" href="#id88" role="doc-backlink">CPU0的指令执行阶段</a><a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-655">Cpu0 架构具有五级流水线。这些阶段是取指（IF）、译码（ID）、执行（EX）、访存（MEM）和读写（WB）。</p>
<p class="linemarker linemarker-657">以下是处理器每个阶段发生的情况描述：</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-660">Instruction fetch (IF)</p></li>
</ol>
<ul class="simple">
<li><p class="linemarker linemarker-662">Cpu0 将由程序计数器（PC）指向的指令抓取到指令寄存器（IR）中：IR = [PC]。</p></li>
<li><p class="linemarker linemarker-663">计算机然后更新到指向下一条指令：PC = PC + 4。</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p class="linemarker linemarker-665">Instruction decode (ID)</p></li>
</ol>
<ul class="simple">
<li><p class="linemarker linemarker-667">控制单元解码存储在IR中的指令，将寄存器中存储的必要数据传送到ALU，并根据当前指令的操作码设置ALU的操作模式。</p></li>
</ul>
<ol class="arabic simple" start="3">
<li><p class="linemarker linemarker-669">Execute (EX)</p></li>
</ol>
<ul class="simple">
<li><p class="linemarker linemarker-671">ALU（算术逻辑单元）根据控制单元指定的操作对寄存器中的数据进行执行。除了加载和存储指令外，在ALU完成后，结果将存储在目标寄存器中。</p></li>
</ul>
<ol class="arabic simple" start="4">
<li><p class="linemarker linemarker-673">Memory access (MEM)</p></li>
</ol>
<ul class="simple">
<li><p class="linemarker linemarker-675">如果是加载指令，则从数据缓存读取数据到流水线寄存器MEM/WB；如果是存储指令，则将数据从寄存器写入数据缓存。</p></li>
</ul>
<ol class="arabic simple" start="5">
<li><p class="linemarker linemarker-677">Write-back (WB)</p></li>
</ol>
<ul class="simple">
<li><p class="linemarker linemarker-679">将来自管道寄存器MEM/WB的数据移至寄存器，如果它是加载指令。</p></li>
</ul>
</section>
<section id="id27">
<h3><a class="toc-backref" href="#id89" role="doc-backlink">CPU0的中断向量</a><a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<table class="docutils align-default" id="id69">
<caption><span class="caption-text">Cpu0’s Interrupt Vector</span><a class="headerlink" href="#id69" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-688">Address</p></th>
<th class="head"><p class="linemarker linemarker-688">type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-690">0x00</p></td>
<td><p class="linemarker linemarker-690">Reset</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-691">0x04</p></td>
<td><p class="linemarker linemarker-691">Error Handle</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-692">0x08</p></td>
<td><p class="linemarker linemarker-692">Interrupt</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="llvm-structure-llvm">
<h2><a class="toc-backref" href="#id90" role="doc-backlink">LLVM Structure（译者：本节是llvm一些基础介绍，熟悉的同学可以直接跳过）</a><a class="headerlink" href="#llvm-structure-llvm" title="Link to this heading"></a></h2>
<p class="linemarker linemarker-699">This section introduces the compiler data structure, algorithm and mechanism
that llvm uses.</p>
<section id="three-phase-design">
<h3><a class="toc-backref" href="#id91" role="doc-backlink">Three-phase design</a><a class="headerlink" href="#three-phase-design" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-705">This content and the following sub-section comes from the AOSA chapter on
LLVM written by Chris Lattner <a class="footnote-reference brackets" href="#aosa-book" id="id28" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>.</p>
<p class="linemarker linemarker-708">The most popular design for a traditional static compiler (like most C
compilers) is the three phase design whose major components are the front end,
the optimizer and the back end, as seen in <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f6</span></code>.
The front end parses source code, checking it for errors, and builds a
language-specific Abstract Syntax Tree (AST) to represent the input code.
The AST is optionally converted to a new representation for optimization, and
the optimizer and back end are run on the code.</p>
<figure class="align-center" id="id70">
<span id="llvmstructure-f6"></span><a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" style="width: 329.0px; height: 44.099999999999994px;" /></a>
<figcaption>
<p><span class="caption-text">Three Major Components of a Three Phase Compiler</span><a class="headerlink" href="#id70" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-725">The optimizer is responsible for doing a broad variety of transformations to
try to improve the code’s running time, such as eliminating redundant
computations, and is usually more or less independent of language and target.
The back end (also known as the code generator) then maps the code onto the
target instruction set.
In addition to making correct code, it is responsible for generating good code
that takes advantage of unusual features of the supported architecture.
Common parts of a compiler back end include instruction selection, register
allocation, and instruction scheduling.</p>
<p class="linemarker linemarker-735">This model applies equally well to interpreters and JIT compilers.
The Java Virtual Machine (JVM) is also an implementation of this model, which
uses Java bytecode as the interface between the front end and optimizer.</p>
<p class="linemarker linemarker-739">The most important win of this classical design comes when a compiler decides
to support multiple source languages or target architectures.
If the compiler uses a common code representation in its optimizer, then a
front end can be written for any language that can compile to it, and a back
end can be written for any target that can compile from it, as shown in
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f7</span></code>.</p>
<figure class="align-center" id="id71">
<span id="llvmstructure-f7"></span><a class="reference internal image-reference" href="_images/7.png"><img alt="_images/7.png" src="_images/7.png" style="width: 585.9px; height: 209.29999999999998px;" /></a>
<figcaption>
<p><span class="caption-text">Retargetablity</span><a class="headerlink" href="#id71" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-755">With this design, porting the compiler to support a new source language (e.g.,
Algol or BASIC) requires implementing a new front end, but the existing
optimizer and back end can be reused.
If these parts weren’t separated, implementing a new source language would
require starting over from scratch, so supporting N targets and M source
languages would need N*M compilers.</p>
<p class="linemarker linemarker-762">Another advantage of the three-phase design (which follows directly from
retargetability) is that the compiler serves a broader set of programmers than
it would if it only supported one source language and one target.
For an open source project, this means that there is a larger community of
potential contributors to draw from, which naturally leads to more enhancements
and improvements to the compiler.
This is the reason why open source compilers that serve many communities (like
GCC) tend to generate better optimized machine code than narrower compilers
like FreePASCAL.
This isn’t the case for proprietary compilers, whose quality is directly
related to the project’s budget.
For example, the Intel ICC Compiler is widely known for the quality of code it
generates, even though it serves a narrow audience.</p>
<p class="linemarker linemarker-776">A final major win of the three-phase design is that the skills required to
implement a front end are different than those required for the optimizer and
back end.
Separating these makes it easier for a “front-end person” to enhance and
maintain their part of the compiler.
While this is a social issue, not a technical one, it matters a lot in
practice, particularly for open source projects that want to reduce the barrier
to contributing as much as possible.</p>
<p class="linemarker linemarker-785">The most important aspect of its design is the LLVM Intermediate Representation
(IR), which is the form it uses to represent code in the compiler.
LLVM IR is designed to host mid-level analyses and transformations that you
find in the optimizer chapter of a compiler.
It was designed with many specific goals in mind, including supporting
lightweight runtime optimizations, cross-function/interprocedural
optimizations, whole program analysis, and aggressive restructuring
transformations, etc.
The most important aspect of it, though, is that it is itself defined as a
first class language with well-defined semantics.
To make this concrete, here is a simple example of a .ll file:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add1</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%tmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%b</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp1</span>
<span class="p">}</span>
<span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add2</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%tmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%tmp1</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%done</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%recurse</span>
<span class="nl">recurse:</span>
<span class="w">  </span><span class="nv">%tmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%tmp3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%tmp4</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@add2</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp2</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp3</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%tmp4</span>
<span class="nl">done:</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Above LLVM IR corresponds to this C code, which provides two different ways to</span>
<span class="c1">//  add integers:</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">add1</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Perhaps not the most efficient way to add two numbers.</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="nf">add2</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">add2</span><span class="p">(</span><span class="n">a</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="linemarker linemarker-830">As you can see from this example, LLVM IR is a low-level RISC-like virtual
instruction set.
Like a real RISC instruction set, it supports linear sequences of simple
instructions like add, subtract, compare, and branch.
These instructions are in three address form, which means that they take some
number of inputs and produce a result in a different register.
LLVM IR supports labels and generally looks like a weird form of assembly
language.</p>
<p class="linemarker linemarker-839">Unlike most RISC instruction sets, LLVM is strongly typed with a simple type
system (e.g., i32 is a 32-bit integer, i32** is a pointer to pointer to 32-bit
integer) and some details of the machine are abstracted away.
For example, the calling convention is abstracted through call and ret
instructions and explicit arguments.
Another significant difference from machine code is that the LLVM IR doesn’t
use a fixed set of named registers, it uses an infinite set of temporaries
named with a % character.</p>
<p class="linemarker linemarker-848">Beyond being implemented as a language, LLVM IR is actually defined in three
isomorphic forms: the textual format above, an in-memory data structure
inspected and modified by optimizations themselves, and an efficient and dense
on-disk binary “bitcode” format.
The LLVM Project also provides tools to convert the on-disk format from text to
binary: llvm-as assembles the textual .ll file into a .bc file containing the
bitcode goop and llvm-dis turns a .bc file into a .ll file.</p>
<p class="linemarker linemarker-856">The intermediate representation of a compiler is interesting because it can be
a “perfect world” for the compiler optimizer: unlike the front end and back end
of the compiler, the optimizer isn’t constrained by either a specific source
language or a specific target machine.
On the other hand, it has to serve both well: it has to be designed to be easy
for a front end to generate and be expressive enough to allow important
optimizations to be performed for real targets.</p>
</section>
<section id="llvm-s-target-description-files-td">
<h3><a class="toc-backref" href="#id92" role="doc-backlink">LLVM’s Target Description Files: .td</a><a class="headerlink" href="#llvm-s-target-description-files-td" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-869">The “mix and match” approach allows target authors to choose what makes sense
for their architecture and permits a large amount of code reuse across
different targets.
This brings up another challenge: each shared component needs to be able to
reason about target specific properties in a generic way.
For example, a shared register allocator needs to know the register file of
each target and the constraints that exist between instructions and their
register operands.
LLVM’s solution to this is for each target to provide a target description
in a declarative domain-specific language (a set of .td files) processed by the
tblgen tool.
The (simplified) build process for the x86 target is shown in
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f8</span></code>.</p>
<figure class="align-center" id="id72">
<span id="llvmstructure-f8"></span><a class="reference internal image-reference" href="_images/8.png"><img alt="_images/8.png" src="_images/8.png" style="width: 595.0px; height: 299.59999999999997px;" /></a>
<figcaption>
<p><span class="caption-text">Simplified x86 Target Definition</span><a class="headerlink" href="#id72" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-892">The different subsystems supported by the .td files allow target authors to
build up the different pieces of their target.
For example, the x86 back end defines a register class that holds all of its
32-bit registers named “GR32” (in the .td files, target specific definitions
are all caps) like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">GR32</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">RegisterClass</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">  </span><span class="p">[</span><span class="n">EAX</span><span class="p">,</span><span class="w"> </span><span class="n">ECX</span><span class="p">,</span><span class="w"> </span><span class="n">EDX</span><span class="p">,</span><span class="w"> </span><span class="n">ESI</span><span class="p">,</span><span class="w"> </span><span class="n">EDI</span><span class="p">,</span><span class="w"> </span><span class="n">EBX</span><span class="p">,</span><span class="w"> </span><span class="n">EBP</span><span class="p">,</span><span class="w"> </span><span class="n">ESP</span><span class="p">,</span>
<span class="w">   </span><span class="n">R8D</span><span class="p">,</span><span class="w"> </span><span class="n">R9D</span><span class="p">,</span><span class="w"> </span><span class="n">R10D</span><span class="p">,</span><span class="w"> </span><span class="n">R11D</span><span class="p">,</span><span class="w"> </span><span class="n">R14D</span><span class="p">,</span><span class="w"> </span><span class="n">R15D</span><span class="p">,</span><span class="w"> </span><span class="n">R12D</span><span class="p">,</span><span class="w"> </span><span class="n">R13D</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p class="linemarker linemarker-904">The language used in .td files are Target(Hardware) Description Language that
let llvm backend compiler engineers to define the transformation for llvm IR
and the machine instructions of their CPUs. In frontend, compiler development
tools provide the “Parser Generator” for compiler development; in backend,
they provide the “Machine Code Generator” for development, as
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure_frontendTblGen</span></code> and <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure_llvmTblGen</span></code>.</p>
<p class="linemarker linemarker-920" id="llvmstructure-llvmtblgen"><span id="llvmstructure-frontendtblgen"></span>Since the c++’s grammar is more context-sensitive than context-free, llvm
frontend project clang uses handcode parser without BNF generator tools.
In backend development, the IR to machine instructions transformation can
get great benefits from TableGen tools. Though c++ compiler cannot get
benefit from BNF generator tools, many computer languages and script languages
are more context-free and can get benefit from the tools.</p>
<p class="linemarker linemarker-927">The following come from wiki:</p>
<p class="linemarker linemarker-929">Java syntax has a context-free grammar that can be parsed by a simple LALR
parser. Parsing C++ is more complicated <a class="footnote-reference brackets" href="#java-cpp" id="id29" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a>.</p>
<p class="linemarker linemarker-932">The gnu g++ compiler abandoned BNF tools since version 3.x.
I think another reason beyond that c++ has more context-sensitive grammar is
handcode parser can provide better error diagnosis than BNF tool since
BNF tool always select the rules from BNF grammar if match.</p>
</section>
<section id="llvm-code-generation-sequence">
<h3><a class="toc-backref" href="#id93" role="doc-backlink">LLVM Code Generation Sequence</a><a class="headerlink" href="#llvm-code-generation-sequence" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-941">Following diagram come from tricore_llvm.pdf.</p>
<figure class="align-center" id="id73">
<span id="llvmstructure-f9"></span><a class="reference internal image-reference" href="_images/9.png"><img alt="_images/9.png" src="_images/9.png" style="width: 1030px; height: 537px;" /></a>
<figcaption>
<p><span class="caption-text">tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</span><a class="headerlink" href="#id73" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-953">LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can be saved in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="w">  </span><span class="c">; store i32 type of 0 to virtual register %a, %a is</span>
<span class="w">            </span><span class="c">;  pointer type which point to i32 value</span>
<span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%c</span><span class="w"> </span><span class="c">; store %b contents to %c point to, %b isi32 type virtual</span>
<span class="w">            </span><span class="c">;  register, %c is pointer type which point to i32 value.</span>
<span class="nv">%a1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a</span><span class="w">    </span><span class="c">; load the memory value where %a point to and assign the</span>
<span class="w">            </span><span class="c">;  memory value to %a1</span>
<span class="nv">%a3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a2</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c">; add %a2 and 1 and save to %a3</span>
</pre></div>
</div>
<p class="linemarker linemarker-971">We explain the code generation process as below.
If you don’t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can read “The LLVM Target-Independent Code Generator” from here <a class="footnote-reference brackets" href="#codegen" id="id30" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>
and “LLVM Language Reference Manual” from here <a class="footnote-reference brackets" href="#langref" id="id31" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a>
before go ahead, but we think the section
4.2 of tricore_llvm.pdf is enough and suggesting you read the web site
documents as above only when you are still not
quite understand, even if you have read the articles of this section and
next two sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-981">Instruction Selection</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="go">//  still is llvm virtual operand.</span>
<span class="go">    store i16 0, i16* %a // store 0 of i16 type to where virtual register %a</span>
<span class="go">                         //  point to.</span>
<span class="go">=&gt;  st i16 0, i32* %a    // Use Cpu0 backend instruction st instead of IR store.</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p class="linemarker linemarker-991">Scheduling and Formation</p></li>
</ol>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="go">//  instructions cycle or in register pressure.</span>
<span class="go">    st i32 %a, i16* %b,  i16 5 // st %a to *(%b+5)</span>
<span class="go">    st %b, i32* %c, i16 0</span>
<span class="gp">    %</span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ld<span class="w"> </span>i32*<span class="w"> </span>%c

<span class="go">// Transfer above instructions order as follows. In RISC CPU of Mips, the ld</span>
<span class="go">//  %c uses the result of the previous instruction st %c. So it must waits 1</span>
<span class="go">//  cycle. Meaning the ld cannot follow st immediately.</span>
<span class="go">=&gt;  st %b, i32* %c, i16 0</span>
<span class="go">    st i32 %a, i16* %b,  i16 5</span>
<span class="gp">    %</span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ld<span class="w"> </span>i32*<span class="w"> </span>%c,<span class="w"> </span>i16<span class="w"> </span><span class="m">0</span>
<span class="go">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="go">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="go">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="go">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
<span class="go">    st i32 %a, i16* %b,  i16 5</span>
<span class="go">    st %b, i32* %c, i16 0</span>
<span class="go">    nop</span>
<span class="gp">    %</span><span class="nv">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ld<span class="w"> </span>i32*<span class="w"> </span>%c,<span class="w"> </span>i16<span class="w"> </span><span class="m">0</span>

<span class="go">// Minimum register pressure</span>
<span class="go">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="go">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="go">// The following no-reorder-version need 3 registers at least</span>
<span class="gp">    %</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="gp">    %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">    st %a,  i32* %c, 1</span>
<span class="go">    st %b,  i32* %c, 2</span>

<span class="go">// The reorder version needs 2 registers only (by allocate %a and %b in the same</span>
<span class="go">//  register)</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="go">    st %a,  i32* %c, 1</span>
<span class="gp">    %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">    st %b,  i32* %c, 2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p class="linemarker linemarker-1032">SSA-based Machine Code Optimization</p>
<p class="linemarker linemarker-1034">For example, common expression remove, shown in next section DAG.</p>
</li>
<li><p class="linemarker linemarker-1036">Register Allocation</p>
<p class="linemarker linemarker-1038">Allocate real register for virtual register.</p>
</li>
<li><p class="linemarker linemarker-1040">Prologue/Epilogue Code Insertion</p>
<p class="linemarker linemarker-1042">Explain in section Add Prologue/Epilogue functions</p>
</li>
<li><p class="linemarker linemarker-1044">Late Machine Code Optimizations</p>
<p class="linemarker linemarker-1046">Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</li>
<li><p class="linemarker linemarker-1050">Code Emission</p>
<p class="linemarker linemarker-1052">Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</li>
</ol>
<p class="linemarker linemarker-1056">The llvm code generation sequence also can be obtained by
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code> as the following. The first 4 code generation
sequences from <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f9</span></code> are in the
<strong>‘DAG-&gt;DAG Pattern Instruction Selection’</strong> of the <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent between <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f9</span></code> and
<code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></code> (please check the * in the following).
No need to be bothered with this since the the LLVM is under development and
changed from time to time.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-79-200:input Jonathan$ </span>llc<span class="w"> </span>--help-hidden
<span class="go">OVERVIEW: llvm system compiler</span>

<span class="go">USAGE: llc [options] &lt;input bitcode&gt;</span>

<span class="go">OPTIONS:</span>
<span class="go">...</span>
<span class="go">  -debug-pass                             - Print PassManager debugging information</span>
<span class="go">    =None                                 -   disable debug output</span>
<span class="go">    =Arguments                            -   print pass arguments to pass to &#39;opt&#39;</span>
<span class="go">    =Structure                            -   print pass structure before run()</span>
<span class="go">    =Executions                           -   print pass name before it is executed</span>
<span class="go">    =Details                              -   print pass details when it is executed</span>

<span class="gp">118-165-79-200:input Jonathan$ </span>llc<span class="w"> </span>-march<span class="o">=</span>mips<span class="w"> </span>-debug-pass<span class="o">=</span>Structure<span class="w"> </span>ch3.bc
<span class="go">...</span>
<span class="go">Target Library Information</span>
<span class="go">Target Transform Info</span>
<span class="go">Data Layout</span>
<span class="go">Target Pass Configuration</span>
<span class="go">No Alias Analysis (always returns &#39;may&#39; alias)</span>
<span class="go">Type-Based Alias Analysis</span>
<span class="go">Basic Alias Analysis (stateless AA impl)</span>
<span class="go">Create Garbage Collector Module Metadata</span>
<span class="go">Machine Module Information</span>
<span class="go">Machine Branch Probability Analysis</span>
<span class="go">  ModulePass Manager</span>
<span class="go">    FunctionPass Manager</span>
<span class="go">      Preliminary module verification</span>
<span class="go">      Dominator Tree Construction</span>
<span class="go">      Module Verifier</span>
<span class="go">      Natural Loop Information</span>
<span class="go">      Loop Pass Manager</span>
<span class="go">        Canonicalize natural loops</span>
<span class="go">      Scalar Evolution Analysis</span>
<span class="go">      Loop Pass Manager</span>
<span class="go">        Canonicalize natural loops</span>
<span class="go">        Induction Variable Users</span>
<span class="go">        Loop Strength Reduction</span>
<span class="go">      Lower Garbage Collection Instructions</span>
<span class="go">      Remove unreachable blocks from the CFG</span>
<span class="go">      Exception handling preparation</span>
<span class="go">      Optimize for code generation</span>
<span class="go">      Insert stack protectors</span>
<span class="go">      Preliminary module verification</span>
<span class="go">      Dominator Tree Construction</span>
<span class="go">      Module Verifier</span>
<span class="go">      Machine Function Analysis</span>
<span class="go">      Natural Loop Information</span>
<span class="go">      Branch Probability Analysis</span>
<span class="go">    * MIPS DAG-&gt;DAG Pattern Instruction Selection</span>
<span class="go">      Expand ISel Pseudo-instructions</span>
<span class="go">      Tail Duplication</span>
<span class="go">      Optimize machine instruction PHIs</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Slot index numbering</span>
<span class="go">      Merge disjoint stack slots</span>
<span class="go">      Local Stack Slot Allocation</span>
<span class="go">      Remove dead machine instructions</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">      Machine Loop Invariant Code Motion</span>
<span class="go">      Machine Common Subexpression Elimination</span>
<span class="go">      Machine code sinking</span>
<span class="go">    * Peephole Optimizations</span>
<span class="go">      Process Implicit Definitions</span>
<span class="go">      Remove unreachable machine basic blocks</span>
<span class="go">      Live Variable Analysis</span>
<span class="go">      Eliminate PHI nodes for register allocation</span>
<span class="go">      Two-Address instruction pass</span>
<span class="go">      Slot index numbering</span>
<span class="go">      Live Interval Analysis</span>
<span class="go">      Debug Variable Analysis</span>
<span class="go">      Simple Register Coalescing</span>
<span class="go">      Live Stack Slot Analysis</span>
<span class="go">      Calculate spill weights</span>
<span class="go">      Virtual Register Map</span>
<span class="go">      Live Register Matrix</span>
<span class="go">      Bundle Machine CFG Edges</span>
<span class="go">      Spill Code Placement Analysis</span>
<span class="go">    * Greedy Register Allocator</span>
<span class="go">      Virtual Register Rewriter</span>
<span class="go">      Stack Slot Coloring</span>
<span class="go">      Machine Loop Invariant Code Motion</span>
<span class="go">    * Prologue/Epilogue Insertion &amp; Frame Finalization</span>
<span class="go">      Control Flow Optimizer</span>
<span class="go">      Tail Duplication</span>
<span class="go">      Machine Copy Propagation Pass</span>
<span class="go">    * Post-RA pseudo instruction expansion pass</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">      Post RA top-down list latency scheduler</span>
<span class="go">      Analyze Machine Code For Garbage Collection</span>
<span class="go">      Machine Block Frequency Analysis</span>
<span class="go">      Branch Probability Basic Block Placement</span>
<span class="go">      Mips Delay Slot Filler</span>
<span class="go">      Mips Long Branch</span>
<span class="go">      MachineDominator Tree Construction</span>
<span class="go">      Machine Natural Loop Construction</span>
<span class="go">    * Mips Assembly Printer</span>
<span class="go">      Delete Garbage Collector Information</span>
</pre></div>
</div>
<ul class="simple">
<li><p class="linemarker linemarker-1170">Since Instructions Scheduling and Dead Code Removing will affect Register
Allocation. However llvm does not go from later pass onto earlier pass again.
The Register Allocation is after Instruction Scheduling. The passes from
Live Variable Analysis to Greedy Register Allocator are passes for Register
Allocation. About Register Allocation Passes are here <a class="footnote-reference brackets" href="#cmu-rac" id="id32" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#ra-wiki" id="id33" role="doc-noteref"><span class="fn-bracket">[</span>15<span class="fn-bracket">]</span></a>.</p></li>
</ul>
</section>
<section id="ssa-form">
<h3><a class="toc-backref" href="#id94" role="doc-backlink">SSA form</a><a class="headerlink" href="#ssa-form" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1180">SSA form says that each variable is assigned exactly once.
LLVM IR is SSA form which has unbounded virtual registers (each variable is
assigned exactly once and is keeped in different virtual register).
As the result, the optimization steps used in code generation sequence which
include stages of <strong>Instruction Selection</strong>, <strong>Scheduling and Formation</strong> and
<strong>Register Allocation</strong>, won’t loss any optimization opportunity.
For example, if using limited virtual registers instead of unlimited as the
following code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">%</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">store i32 %a, i32* %c, align 4</span>
<span class="gp">%</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">store i32 %a, i32* %c, align 4</span>
</pre></div>
</div>
<p class="linemarker linemarker-1196">Above using limited virtual registers, so virtual register %a used twice.
Compiler have to generate the following code since it assigns virtual register
%a as output at two different statement.</p>
<blockquote>
<div><dl class="simple">
<dt>=&gt; %a = add i32 1, i32 0</dt><dd><p class="linemarker linemarker-1201">st %a,  i32* %c, 1
%a = add i32 2, i32 0
st %a,  i32* %c, 2</p>
</dd>
</dl>
</div></blockquote>
<p class="linemarker linemarker-1205">Above code have to run in sequence. On the other hand, the SSA form as the
following can be reodered and run in parallel with the following different
version <a class="footnote-reference brackets" href="#dragonbooks-10-2-3" id="id34" role="doc-noteref"><span class="fn-bracket">[</span>16<span class="fn-bracket">]</span></a>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">  %</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">  store i32 %a, i32* %c, align 4</span>
<span class="gp">  %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>nsw<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">  store i32 %b, i32* %d, align 4</span>

<span class="go">// version 1</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="go">    st %a,  i32* %c, 0</span>
<span class="gp">    %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">    st %b,  i32* %d, 0</span>

<span class="go">// version 2</span>
<span class="go">=&gt; %a = add i32 1, i32 0</span>
<span class="gp">    %</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">2</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">    st %a,  i32* %c, 0</span>
<span class="go">    st %b,  i32* %d, 0</span>

<span class="go">// version 3</span>
<span class="go">=&gt; %b = add i32 2, i32 0</span>
<span class="go">    st %b,  i32* %d, 0</span>
<span class="gp">    %</span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>add<span class="w"> </span>i32<span class="w"> </span><span class="m">1</span>,<span class="w"> </span>i32<span class="w"> </span><span class="m">0</span>
<span class="go">    st %a,  i32* %c, 0</span>
</pre></div>
</div>
</section>
<section id="dsa-form">
<h3><a class="toc-backref" href="#id95" role="doc-backlink">DSA form</a><a class="headerlink" href="#dsa-form" title="Link to this heading"></a></h3>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">for (int i = 0; i &lt; 1000; i++) {</span>
<span class="go">  b[i] = f(g(a[i]));</span>
<span class="go">}</span>
</pre></div>
</div>
<p class="linemarker linemarker-1244">For the source program as above, the following are the SSA form in source code
level and llvm IR level respectively.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span>
<span class="nl">true:</span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span>
<span class="w">  </span><span class="nv">%t</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span>
<span class="nl">end:</span>
</pre></div>
</div>
<p class="linemarker linemarker-1271">The following is the DSA (Dynamic Single Assignment) form.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span>
<span class="nl">true:</span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span>
<span class="nl">end:</span>
</pre></div>
</div>
<p class="linemarker linemarker-1298">In some internet video applications and muti-core (SMP) platforms, splitting g()
and f() to two different loop have better perfomance. DSA can split as the
following while SSA cannot. Of course, it’s possible to do extra analysis on
%temp of SSA and reverse it into %t_idx and %t_addr as the following DSA. But in
compiler discussion, the translation is from high to low level of machine code.
Besides, as you see, the llvm ir lose the for loop information already though
it can be reconstructed by extra analysis. So, in this book and almost every
paper in compiler discuss with this high-to-low premise, otherwise it’s talking
about reverse engineering in assembler or compiler.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span>
<span class="nl">true:</span>
<span class="w">  </span><span class="nv">%a_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a_addr</span>
<span class="w">  </span><span class="nv">%val0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%a_idx</span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%g</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val0</span><span class="p">)</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span>
<span class="nl">end:</span>

<span class="w">  </span><span class="nv">%pi</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%pi</span>
<span class="w">  </span><span class="nv">%cmp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="m">1000</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%true</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%end</span>
<span class="nl">true:</span>
<span class="w">  </span><span class="nv">%t_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%t_addr</span>
<span class="w">  </span><span class="nv">%temp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%t_idx</span>
<span class="w">  </span><span class="nv">%val1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%f</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%temp</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%b_idx</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b_addr</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%val1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">*</span><span class="w"> </span><span class="nv">%b_idx</span>
<span class="nl">end:</span>
</pre></div>
</div>
<p class="linemarker linemarker-1347">Now, the data dependences only exist on t[i] between “t[i] = g(a[i])” and
“b[i] = f(t[i])” for each i = (0..999). The program can be run on many different
order, and it provides many parallel processing opportunities for multi-core
(SMP) and heterogeneous processors. For instance, g(x) is run on GPU and f(x)
is run on CPU.</p>
</section>
<section id="llvm-vs-gcc-in-structure">
<h3><a class="toc-backref" href="#id96" role="doc-backlink">LLVM vs GCC in structure</a><a class="headerlink" href="#llvm-vs-gcc-in-structure" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1357">GCC document is here <a class="footnote-reference brackets" href="#gnu" id="id35" role="doc-noteref"><span class="fn-bracket">[</span>17<span class="fn-bracket">]</span></a> .</p>
<table class="docutils align-default" id="id74">
<caption><span class="caption-text">clang vs gcc-frontend</span><a class="headerlink" href="#id74" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-1362">frontend</p></th>
<th class="head"><p class="linemarker linemarker-1362">clang</p></th>
<th class="head"><p class="linemarker linemarker-1362">gcc-frontend <a class="footnote-reference brackets" href="#gcc-frontend" id="id36" role="doc-noteref"><span class="fn-bracket">[</span>18<span class="fn-bracket">]</span></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-1364">LANGUAGE</p></td>
<td><p class="linemarker linemarker-1364">C/C++</p></td>
<td><p class="linemarker linemarker-1364">C/C++</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-1365">parsing</p></td>
<td><p class="linemarker linemarker-1365">parsing</p></td>
<td><p class="linemarker linemarker-1365">parsing</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-1366">AST</p></td>
<td><p class="linemarker linemarker-1366">clang-AST</p></td>
<td><p class="linemarker linemarker-1366">GENERIC <a class="footnote-reference brackets" href="#generic" id="id37" role="doc-noteref"><span class="fn-bracket">[</span>19<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-1367">optimization &amp; codgen</p></td>
<td><p class="linemarker linemarker-1367">clang-backend</p></td>
<td><p class="linemarker linemarker-1367">gimplifier</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-1368">IR</p></td>
<td><p class="linemarker linemarker-1368">LLVM IR</p></td>
<td><p class="linemarker linemarker-1368">GIMPLE <a class="footnote-reference brackets" href="#gimple" id="id38" role="doc-noteref"><span class="fn-bracket">[</span>20<span class="fn-bracket">]</span></a></p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id75">
<caption><span class="caption-text">llvm vs gcc (kernal and target/backend)</span><a class="headerlink" href="#id75" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-1374">backend</p></th>
<th class="head"><p class="linemarker linemarker-1374">llvm</p></th>
<th class="head"><p class="linemarker linemarker-1374">gcc</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-1376">IR</p></td>
<td><p class="linemarker linemarker-1376">LLVM IR</p></td>
<td><p class="linemarker linemarker-1376">GIMPLE</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-1377">transfer</p></td>
<td><p class="linemarker linemarker-1377">optimziation &amp; pass</p></td>
<td><p class="linemarker linemarker-1377">optimization &amp; plugins</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-1378">DAG</p></td>
<td><p class="linemarker linemarker-1378">DAG</p></td>
<td><p class="linemarker linemarker-1378">RTL <a class="footnote-reference brackets" href="#rtl" id="id39" role="doc-noteref"><span class="fn-bracket">[</span>21<span class="fn-bracket">]</span></a></p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-1379">codgen</p></td>
<td><p class="linemarker linemarker-1379">tblgen for td</p></td>
<td><p class="linemarker linemarker-1379">codgen for md <a class="footnote-reference brackets" href="#md" id="id40" role="doc-noteref"><span class="fn-bracket">[</span>22<span class="fn-bracket">]</span></a></p></td>
</tr>
</tbody>
</table>
<p class="linemarker linemarker-1382">Both LLVM IR and GIMPLE are SSA form.
LLVM IR originally designed to be fully reusable across arbitrary tools besides
compiler itself. GCC community never had desire to enable any tools besides
compiler (Richard Stallman resisted attempts to make IR more reusable to prevent
third-party commercial tools from reusing GCC’s frontends). Thus GIMPLE
(GCC’s IR) was never considered to be more than an implementation detail, in
particular it doesn’t provide a full description of compiled program (e.g. it
lacks program’s call graph, type definitions, stack offsets and alias
information) <a class="footnote-reference brackets" href="#llvm-ir-vs-gimple" id="id41" role="doc-noteref"><span class="fn-bracket">[</span>23<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="llvm-blog">
<h3><a class="toc-backref" href="#id97" role="doc-backlink">LLVM blog</a><a class="headerlink" href="#llvm-blog" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1395">User uses null pointer to guard code is correct. Undef is only happened in
compiler optimization <a class="footnote-reference brackets" href="#null-pointer-ex" id="id42" role="doc-noteref"><span class="fn-bracket">[</span>24<span class="fn-bracket">]</span></a>.
However when user forget to bind null pointer in guarding code directly or
indirectly, compiler such as llvm and gcc may treat null pointer as undef and
optimzation out <a class="footnote-reference brackets" href="#null-pointer" id="id43" role="doc-noteref"><span class="fn-bracket">[</span>25<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="cfg-control-flow-graph">
<h3><a class="toc-backref" href="#id98" role="doc-backlink">CFG (Control Flow Graph)</a><a class="headerlink" href="#cfg-control-flow-graph" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1405">The SSA form can be depicted in CFG and do optimization through the analysis on
CFG. Each node in the graph represents a basic block, i.e. a straight-line piece
of code without any jumps or jump targets; jump targets start a block, and jumps
end a block <a class="footnote-reference brackets" href="#cfg-wiki" id="id44" role="doc-noteref"><span class="fn-bracket">[</span>26<span class="fn-bracket">]</span></a>.</p>
<p class="linemarker linemarker-1410">The following is an example of CFG. <strong>The jump/branch always in the last
statement of BBs (Basic Blocks)</strong> in <code class="xref std std-numref docutils literal notranslate"><span class="pre">cfg_ex</span></code>.</p>
<p class="rubric">Fig/llvmstructure/cfg-ex.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">cfg_ex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">      </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">goto</span><span class="w"> </span><span class="n">label_1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="nl">label_1</span><span class="p">:</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">10</span><span class="p">:</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Fig/llvmstructure/cfg-ex.ll</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@_Z6cfg_exiii</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="k">signext</span><span class="w"> </span><span class="nv">%n</span><span class="p">)</span><span class="w"> </span><span class="k">local_unnamed_addr</span><span class="w"> </span><span class="k">nounwind</span><span class="w"> </span><span class="p">{</span>
<span class="nl">entry:</span>
<span class="w">  </span><span class="nv">%cmp.not23</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%n</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp.not23</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%for.body</span>

<span class="nl">for.cond:</span><span class="w">                                         </span><span class="c">; preds = %for.body</span>
<span class="w">  </span><span class="nv">%inc</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nuw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i.026</span><span class="p">,</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="nv">%exitcond.not</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i.026</span><span class="p">,</span><span class="w"> </span><span class="nv">%n</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%exitcond.not</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%for.body</span><span class="p">,</span><span class="w"> </span><span class="nv">!llvm.loop</span><span class="w"> </span><span class="nv nv-Anonymous">!2</span>

<span class="nl">for.body:</span><span class="w">                                         </span><span class="c">; preds = %entry, %for.cond</span>
<span class="w">  </span><span class="nv">%i.026</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%inc</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.cond</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%a.addr.025</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%a.addr.1</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.cond</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%b.addr.024</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%b.addr.1</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.cond</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%cmp1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">slt</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a.addr.025</span><span class="p">,</span><span class="w"> </span><span class="nv">%b.addr.024</span>
<span class="w">  </span><span class="nv">%sub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sext</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i32</span>
<span class="w">  </span><span class="nv">%b.addr.1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b.addr.024</span><span class="p">,</span><span class="w"> </span><span class="nv">%sub</span>
<span class="w">  </span><span class="nv">%add</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp1</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%i.026</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="nv">%a.addr.1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add</span><span class="p">,</span><span class="w"> </span><span class="nv">%a.addr.025</span>
<span class="w">  </span><span class="nv">%cmp2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%b.addr.1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp2</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%cleanup</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%for.cond</span>

<span class="nl">cleanup:</span><span class="w">                                          </span><span class="c">; preds = %for.cond, %for.body, %entry</span>
<span class="w">  </span><span class="nv">%b.addr.2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%b</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.body</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%b.addr.1</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.cond</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%a.addr.2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">phi</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%entry</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%a.addr.1</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.body</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="nv">%a.addr.1</span><span class="p">,</span><span class="w"> </span><span class="nv">%for.cond</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="nv">%cond</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a.addr.2</span><span class="p">,</span><span class="w"> </span><span class="m">10</span>
<span class="w">  </span><span class="nv">%inc7</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">sub</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">103</span><span class="p">,</span><span class="w"> </span><span class="nv">%b.addr.2</span>
<span class="w">  </span><span class="nv">%spec.select</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cond</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%inc7</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%a.addr.2</span>
<span class="w">  </span><span class="nv">%add8</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">nsw</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%spec.select</span><span class="p">,</span><span class="w"> </span><span class="nv">%b.addr.2</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%add8</span>
<span class="p">}</span>


<span class="nv">!llvm.module.flags</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!0</span><span class="p">}</span>
<span class="nv">!llvm.ident</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!1</span><span class="p">}</span>

<span class="nv nv-Anonymous">!0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="kt">i32</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!&quot;wchar_size&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">4</span><span class="p">}</span>
<span class="nv nv-Anonymous">!1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv">!&quot;clang version 12.0.1&quot;</span><span class="p">}</span>
<span class="nv nv-Anonymous">!2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="p">!{</span><span class="nv nv-Anonymous">!2</span><span class="p">,</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span><span class="p">}</span>
<span class="nv nv-Anonymous">!3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv">!&quot;llvm.loop.mustprogress&quot;</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="dag-directed-acyclic-graph">
<span id="cfg-ex"></span><h3><a class="toc-backref" href="#id99" role="doc-backlink">DAG (Directed Acyclic Graph)</a><a class="headerlink" href="#dag-directed-acyclic-graph" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1429">The SSA in each BB (Basic Block) from CFG as the previous section can be
represented in DAG.</p>
<p class="linemarker linemarker-1432">Many important techniques for local optimization begin by transforming a basic
block into DAG <a class="footnote-reference brackets" href="#dragonbooks-8-5" id="id45" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>.
For example, the basic block code and it’s corresponding DAG as
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f10</span></code>.</p>
<figure class="align-center" id="id76">
<span id="llvmstructure-f10"></span><a class="reference internal image-reference" href="_images/10.png"><img alt="_images/10.png" src="_images/10.png" style="width: 379.20000000000005px; height: 142.4px;" /></a>
<figcaption>
<p><span class="caption-text">DAG example</span><a class="headerlink" href="#id76" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-1446">If b is not live on exit from the block, then we can do “common expression
remove” as the following table.</p>
<table class="docutils align-default" id="id77">
<caption><span class="caption-text">common expression remove process</span><a class="headerlink" href="#id77" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-1452">Replace node b with node d</p></th>
<th class="head"><p class="linemarker linemarker-1452">Replace b<sub>0</sub>, c<sub>0</sub>, d<sub>0</sub> with b, c, d</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-1454">a = b<sub>0</sub> + c<sub>0</sub></p></td>
<td><p class="linemarker linemarker-1454">a = b + c</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-1455">d = a – d<sub>0</sub></p></td>
<td><p class="linemarker linemarker-1455">d = a – d</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-1456">c = d + c</p></td>
<td><p class="linemarker linemarker-1456">c = d + c</p></td>
</tr>
</tbody>
</table>
<p class="linemarker linemarker-1459">After removing b and traversing the DAGs from bottom to top (traverse binary
tree by Depth-first In-order search) , the first column of above table will be
gotten.</p>
<p class="linemarker linemarker-1463">As you can imagine, the “common expression remove” can apply both in IR or
machine code.</p>
<p class="linemarker linemarker-1466">DAG is like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
<p class="linemarker linemarker-1471">In addition to DAG optimization, the “kill” register has also mentioned in
section 8.5.5 of the compiler book <a class="footnote-reference brackets" href="#dragonbooks-8-5" id="id46" role="doc-noteref"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></a>. This optimization
method also applied in llvm implementation.</p>
</section>
<section id="instruction-selection">
<h3><a class="toc-backref" href="#id100" role="doc-backlink">Instruction Selection</a><a class="headerlink" href="#instruction-selection" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1479">The major function of backend is that translate IR code into machine code at
stage of Instruction Selection as <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f11</span></code>.</p>
<figure class="align-center" id="id78">
<span id="llvmstructure-f11"></span><a class="reference internal image-reference" href="_images/11.png"><img alt="_images/11.png" src="_images/11.png" style="width: 346.5px; height: 81.19999999999999px;" /></a>
<figcaption>
<p><span class="caption-text">IR and it’s corresponding machine instruction</span><a class="headerlink" href="#id78" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-1491">For machine instruction selection, the best solution is representing IR and
machine instruction by DAG.
To simplify in view, the register leaf is skipped in
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f12</span></code>.
The r<sub>j</sub> + r<sub>k</sub> is IR DAG representation (for symbol
notation, not llvm SSA form).
ADD is machine instruction.</p>
<figure class="align-center" id="id79">
<span id="llvmstructure-f12"></span><a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" style="width: 690.1999999999999px; height: 426.29999999999995px;" /></a>
<figcaption>
<p><span class="caption-text">Instruction DAG representation</span><a class="headerlink" href="#id79" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-1508">The IR DAG and machine instruction DAG can also represented as list.
For example, (+ r<sub>i</sub>, r<sub>j</sub>j) and (- r<sub>i</sub>, 1) are
lists for IR DAG; (ADD r<sub>i</sub>, r<sub>j</sub>) and
(SUBI r<sub>i</sub>, 1) are lists for machine instruction DAG.</p>
<p class="linemarker linemarker-1513">Now, let’s check the ADDiu instruction defined in Cpu0InstrInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrFormats.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span> <span class="n">Format</span> <span class="n">L</span> <span class="n">instruction</span> <span class="k">class</span> <span class="nc">in</span> <span class="n">Cpu0</span> <span class="p">:</span> <span class="o">&lt;|</span><span class="n">opcode</span><span class="o">|</span><span class="n">ra</span><span class="o">|</span><span class="n">rb</span><span class="o">|</span><span class="n">cx</span><span class="o">|&gt;</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="nb">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;</span><span class="p">:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Node</span> <span class="n">immediate</span> <span class="n">fits</span> <span class="k">as</span> <span class="mi">16</span><span class="o">-</span><span class="n">bit</span> <span class="n">sign</span> <span class="n">extended</span> <span class="n">on</span> <span class="n">target</span> <span class="n">immediate</span><span class="o">.</span>
<span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">addi</span><span class="p">,</span> <span class="n">andi</span>
<span class="k">def</span> <span class="nf">immSExt16</span>  <span class="p">:</span> <span class="n">PatLeaf</span><span class="o">&lt;</span><span class="p">(</span><span class="n">imm</span><span class="p">),</span> <span class="p">[{</span> <span class="k">return</span> <span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">());</span> <span class="p">}]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">IR</span> <span class="s2">&quot;add&quot;</span> <span class="n">defined</span> <span class="ow">in</span> <span class="n">include</span><span class="o">/</span><span class="n">llvm</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">TargetSelectionDAG</span><span class="o">.</span><span class="n">td</span><span class="p">,</span> <span class="n">line</span> <span class="mi">315</span> <span class="p">(</span><span class="k">def</span> <span class="nf">add</span><span class="p">)</span><span class="o">.</span>
<span class="k">def</span> <span class="nf">ADDiu</span>   <span class="p">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x09</span><span class="p">,</span> <span class="s2">&quot;addiu&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="linemarker linemarker-1532"><code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f13</span></code> shows how the pattern match work in the IR node,
<strong>add</strong>, and instruction node, <strong>ADDiu</strong>, which both defined in
Cpu0InstrInfo.td. In
this example, IR node “add %a, 5” will be translated to “addiu $r1, 5” after %a
is allcated to register $r1 in regiter allocation stage since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is “signed immediate” which matched “%a, 5”. In addition to pattern
match, the .td also set assembly string “addiu” and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction can be issued in obj
file of ELF format which will be explained at later chapter).
Similarly, the machine instruction DAG nodes LD and ST can be translated from IR
DAG nodes <strong>load</strong> and <strong>store</strong>. Notice that the $rb in
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f13</span></code> is virtual register name (not machine register).
The detail for <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f13</span></code> is depicted as
<code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-dag</span></code>.</p>
<figure class="align-center" id="id80">
<span id="llvmstructure-f13"></span><a class="reference internal image-reference" href="_images/13.png"><img alt="_images/13.png" src="_images/13.png" style="width: 514.4px; height: 336.8px;" /></a>
<figcaption>
<p><span class="caption-text">Pattern match for ADDiu instruction and IR node add</span><a class="headerlink" href="#id80" title="Link to this image"></a></p>
</figcaption>
</figure>
<p class="linemarker linemarker-1563" id="llvmstructure-dag">From DAG instruction selection we mentioned, the leaf node must be a Data Node.
ADDiu is format L type which the last operand must fits in 16 bits range.
So, Cpu0InstrInfo.td define a PatLeaf type of immSExt16 to let llvm system know
the PatLeaf range. If the imm16 value is out of this range,
<strong>“isInt&lt;16&gt;(N-&gt;getSExtValue())”</strong> will return false and this pattern won’t use
ADDiu in instruction selection stage.</p>
<p class="linemarker linemarker-1570">Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          &quot;fmadds $FRT, $FRA, $FRC, $FRB&quot;,
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;
</pre></div>
</div>
<p class="linemarker linemarker-1584">Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<p class="linemarker linemarker-1587">Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>d = a * c
e = d + b
...
</pre></div>
</div>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv">%d</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fmul</span><span class="w"> </span><span class="nv">%a</span><span class="p">,</span><span class="w"> </span><span class="nv">%c</span>
<span class="nv">%e</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">fadd</span><span class="w"> </span><span class="nv">%d</span><span class="p">,</span><span class="w"> </span><span class="nv">%b</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-1601">the Instruction Selection Process will translate this two IR DAG node
(fmul %a, %c) (fadd %d, %b) into one machine instruction DAG node (<strong>fmadd</strong>
%a, %c, %b), rather than translate them into two machine instruction nodes
<strong>fmul</strong> and <strong>fadd</strong> if the FMADDS is appear before FMUL and FADD in your td
file.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">%</span><span class="nv">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>fmadd<span class="w"> </span>%a,<span class="w"> </span>%c,<span class="w"> </span>%b
<span class="go">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-1612">As you can see, the IR notation representation is easier to read than llvm SSA
IR form.
So, this notation form is used in this book sometimes.</p>
<p class="linemarker linemarker-1616">For the following basic block code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">a = b + c   // in notation IR form</span>
<span class="go">d = a – d</span>
<span class="gp">%</span><span class="nv">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>fmadd<span class="w"> </span>%a,<span class="w"> </span>%c,<span class="w"> </span>%b<span class="w"> </span>//<span class="w"> </span><span class="k">in</span><span class="w"> </span>llvm<span class="w"> </span>SSA<span class="w"> </span>IR<span class="w"> </span>form
</pre></div>
</div>
<p class="linemarker linemarker-1624">We can apply <code class="xref std std-numref docutils literal notranslate"><span class="pre">llvmstructure-f8</span></code> Instruction Tree Patterns to get the
following machine code,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">load  rb, M(sp+8); // assume b allocate in sp+8, sp is stack point register</span>
<span class="go">load  rc, M(sp+16);</span>
<span class="go">add ra, rb, rc;</span>
<span class="go">load  rd, M(sp+24);</span>
<span class="go">sub rd, ra, rd;</span>
<span class="go">fmadd re, ra, rc, rb;</span>
</pre></div>
</div>
</section>
<section id="caller-and-callee-saved-registers">
<h3><a class="toc-backref" href="#id101" role="doc-backlink">Caller and callee saved registers</a><a class="headerlink" href="#caller-and-callee-saved-registers" title="Link to this heading"></a></h3>
<p class="rubric">lbdex/input/ch9_caller_callee_save_registers.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">add1</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">callee</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="nb">int</span> <span class="n">t1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add1</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>  
  <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">-</span> <span class="n">t1</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="linemarker linemarker-1644">Run Mips backend with above input will get the following result.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/debug/build/bin/llc
<span class="go">-O0 -march=mips -relocation-model=static -filetype=asm</span>
<span class="go">ch9_caller_callee_save_registers.bc -o -</span>
<span class="go">      .text</span>
<span class="go">      .abicalls</span>
<span class="go">      .option pic0</span>
<span class="go">      .section        .mdebug.abi32,&quot;&quot;,@progbits</span>
<span class="go">      .nan    legacy</span>
<span class="go">      .file   &quot;ch9_caller_callee_save_registers.bc&quot;</span>
<span class="go">      .text</span>
<span class="go">      .globl  _Z6calleev</span>
<span class="go">      .align  2</span>
<span class="go">      .type   _Z6calleev,@function</span>
<span class="go">      .set    nomicromips</span>
<span class="go">      .set    nomips16</span>
<span class="go">      .ent    _Z6calleev</span>
<span class="go">_Z6callerv:                             # @_Z6callerv</span>
<span class="go">      .cfi_startproc</span>
<span class="go">      .frame  $fp,32,$ra</span>
<span class="go">      .mask   0xc0000000,-4</span>
<span class="go">      .fmask  0x00000000,0</span>
<span class="go">      .set    noreorder</span>
<span class="go">      .set    nomacro</span>
<span class="go">      .set    noat</span>
<span class="gp"># </span>BB#0:
<span class="go">      addiu   $sp, $sp, -32</span>
<span class="gp">$</span>tmp0:
<span class="go">      .cfi_def_cfa_offset 32</span>
<span class="go">      sw      $ra, 28($sp)            # 4-byte Folded Spill</span>
<span class="go">      sw      $fp, 24($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp1:
<span class="go">      .cfi_offset 31, -4</span>
<span class="gp">$</span>tmp2:
<span class="go">      .cfi_offset 30, -8</span>
<span class="go">      move     $fp, $sp</span>
<span class="gp">$</span>tmp3:
<span class="go">      .cfi_def_cfa_register 30</span>
<span class="go">      addiu   $1, $zero, 3</span>
<span class="go">      sw      $1, 20($fp)   # store t1 to 20($fp)</span>
<span class="go">      move     $4, $1</span>
<span class="go">      jal     _Z4add1i</span>
<span class="go">      nop</span>
<span class="go">      sw      $2, 16($fp)   # $2 : the return vaule for fuction add1()</span>
<span class="go">      lw      $1, 20($fp)   # load t1 from 20($fp)</span>
<span class="go">      subu    $1, $2, $1</span>
<span class="go">      sw      $1, 16($fp)</span>
<span class="go">      move     $2, $1     # move result to return register $2</span>
<span class="go">      move     $sp, $fp</span>
<span class="go">      lw      $fp, 24($sp)            # 4-byte Folded Reload</span>
<span class="go">      lw      $ra, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">      addiu   $sp, $sp, 32</span>
<span class="go">      jr      $ra</span>
<span class="go">      nop</span>
<span class="go">      .set    at</span>
<span class="go">      .set    macro</span>
<span class="go">      .set    reorder</span>
<span class="go">      .end    _Z6calleev</span>
<span class="gp">$</span>func_end0:
<span class="go">      .size   _Z6calleev, ($func_end0)-_Z6calleev</span>
<span class="go">      .cfi_endproc</span>
</pre></div>
</div>
<p class="linemarker linemarker-1709">Caller and callee saved registers definition as follows,</p>
<ul class="simple">
<li><p class="linemarker linemarker-1711">If the caller wants to use caller-saved registers after callee function, it
must save caller-saved registers’ content to memory for using and restore
these registers from memory after function call.</p></li>
<li><p class="linemarker linemarker-1715">If the callee wants to use callee-saved registers, it must save its content
to memory before using them and restore these registers from memory before
return.</p></li>
</ul>
<p class="linemarker linemarker-1719">As above definition, if a register is not a callee-saved-registers, then it
must be caller-saved-registers because the callee doesn’t retore it and the
value is changed after callee function.
So, Mips only define the callee-saved registers in MipsCallingConv.td, and
can be found in CSR_O32_SaveList of MipsGenRgisterInfo.inc for the default
ABI.</p>
<p class="linemarker linemarker-1726">As above assembly output, Mips allocates t1 variable to register $1 and no need
to spill $1 since $1 is caller saved register.
On the other hand, $ra is callee saved register, so it spills at beginning of
the assembly output since jal uses $ra register.
Cpu0 $lr is the same register as Mips $ra, so it calls setAliasRegs(MF,
SavedRegs, Cpu0::LR) in determineCalleeSaves() of Cpu0SEFrameLowering.cpp when
the function has called another function.</p>
</section>
<section id="live-in-and-live-out-register">
<h3><a class="toc-backref" href="#id102" role="doc-backlink">Live in and live out register</a><a class="headerlink" href="#live-in-and-live-out-register" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1738">As the example of last sub-section. The $ra is “live in” register since the
return address is decided by caller. The $2 is “live out” register since the
return value of the function is saved in this register, and caller can get the
result by read it directly as the comment in above example.
Through mark “live in” and “live out” registers, backend provides
llvm middle layer information to remove useless instructions in variables
access.
Of course, llvm applies the DAG analysis mentioned in the previous sub-section
to finish it.
Since C supports seperate compilation for different functions, the “live in”
and “out” information from backend provides the optimization opportunity to
llvm.
LLVM provides function addLiveIn() to mark “live in” register but no function
addLiveOut() provided.
For the “live out” register, Mips backend marks it by
DAG=DAG.getCopyToReg(…, $2, …) and return DAG instead, since all local
varaiables are not exist after function exit.</p>
</section>
</section>
<section id="id47">
<h2><a class="toc-backref" href="#id103" role="doc-backlink">创建Cpu0后端</a><a class="headerlink" href="#id47" title="Link to this heading"></a></h2>
<p class="linemarker linemarker-1760">从现在开始，将逐步从头开始创建Cpu0后端。为了让读者更容易理解后端结构，
可以通过此处的命令逐章生成Cpu0示例代码 <a class="footnote-reference brackets" href="#chapters-ex" id="id48" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>。Cpu0示例代码lbdex可在此网站的左下方附近找到。
或者在这里 <a class="reference external" href="http://jonathan2251.github.io/lbd/lbdex.tar.gz">http://jonathan2251.github.io/lbd/lbdex.tar.gz</a>。</p>
<section id="cpu0-id">
<h3><a class="toc-backref" href="#id104" role="doc-backlink">CPU0 后端机器 ID 和重定位记录</a><a class="headerlink" href="#cpu0-id" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-1768">创建新的后端需要修改&lt;&lt;llvm根目录&gt;&gt;中的一些文件。添加的信息包括机器的ID和名称，以及重定位记录。
章节“ELF支持”包括重定位记录的介绍。以下文件已修改以添加Cpu0后端，</p>
<p class="rubric">lbdex/llvm/modify/llvm/config-ix.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>...
elseif (LLVM_NATIVE_ARCH MATCHES &quot;cpu0&quot;)
  set(LLVM_NATIVE_ARCH Cpu0)
...
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/CMakeLists.txt</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">LLVM_ALL_TARGETS</span>
<span class="w">  </span><span class="s">...</span>
<span class="w">  </span><span class="s">Cpu0</span>
<span class="w">  </span><span class="s">...</span>
<span class="w">  </span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/ADT/Triple.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="cp">#undef mips</span>
<span class="cp">#undef cpu0</span>
<span class="p">...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Triple</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="nc">ArchType</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="n">cpu0</span><span class="p">,</span><span class="w">       </span><span class="c1">// For Tutorial Backend Cpu0</span>
<span class="w">    </span><span class="n">cpu0el</span><span class="p">,</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/Object/ELFObjectFile.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">getFileFormatName</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">ELFCLASS32</span><span class="p">:</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w">        </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;ELF32-cpu0&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ELFT</span><span class="o">&gt;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">ELFObjectFile</span><span class="o">&lt;</span><span class="n">ELFT</span><span class="o">&gt;::</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsLittleEndian</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ELFT</span><span class="o">::</span><span class="n">TargetEndianness</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">support</span><span class="o">::</span><span class="n">little</span><span class="p">;</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span><span class="w">  </span><span class="c1">// llvm-objdump -t -r</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">EF</span><span class="p">.</span><span class="n">getHeader</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">ELF</span><span class="o">::</span><span class="n">EI_CLASS</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">ELFCLASS32</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IsLittleEndian</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="n">report_fatal_error</span><span class="p">(</span><span class="s">&quot;Invalid ELFCLASS!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/include/llvm/Support/ELF.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="n">EM_CPU0</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">999</span><span class="w">  </span><span class="c1">// Document LLVM Backend Tutorial Cpu0</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// Cpu0 Specific e_flags</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">EF_CPU0_NOREORDER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000001</span><span class="p">,</span><span class="w"> </span><span class="c1">// Don&#39;t reorder instructions</span>
<span class="w">  </span><span class="n">EF_CPU0_PIC</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mh">0x00000002</span><span class="p">,</span><span class="w"> </span><span class="c1">// Position independent code</span>
<span class="w">  </span><span class="n">EF_CPU0_ARCH_32</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mh">0x50000000</span><span class="p">,</span><span class="w"> </span><span class="c1">// CPU032 instruction set per linux not elf.h</span>
<span class="w">  </span><span class="n">EF_CPU0_ARCH</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="mh">0xf0000000</span><span class="w">  </span><span class="c1">// Mask for applying EF_CPU0_ARCH_ variant</span>
<span class="p">};</span>

<span class="c1">// ELF Relocation types for Mips</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;ELFRelocs/Cpu0.def&quot;</span>
<span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/MC/MCSubtargetInfo.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MCSubtargetInfo::InitMCProcessorInfo</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">FS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cp">#if 1 </span><span class="c1">// Disable reconginized processor message. For Cpu0</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="w"> </span><span class="o">||</span>
<span class="w">      </span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span>
<span class="w">    </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="cp">#endif</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">const</span><span class="w"> </span><span class="n">MCSchedModel</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MCSubtargetInfo</span><span class="o">::</span><span class="n">getSchedModelForCPU</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="cp">#if 1 </span><span class="c1">// Disable reconginized processor message. For Cpu0</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="n">TargetTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span>
<span class="w">    </span><span class="cp">#endif</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/MC/SubtargetFeature.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">;</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="p">...</span>
<span class="n">FeatureBitset</span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">ToggleFeature</span><span class="p">(</span><span class="n">FeatureBitset</span><span class="w"> </span><span class="n">Bits</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Feature</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">FeatureBitset</span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">ApplyFeatureFlag</span><span class="p">(</span><span class="n">FeatureBitset</span><span class="w"> </span><span class="n">Bits</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">Feature</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">FeatureBitset</span>
<span class="n">SubtargetFeatures</span><span class="o">::</span><span class="n">getFeatureBits</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">CPU</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CPUTable</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">SubtargetFeatureKV</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FeatureTable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Cpu0DisableUnreconginizedMessage</span><span class="p">)</span><span class="w"> </span><span class="c1">// For Cpu0</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lib/object/ELF.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>

<span class="n">StringRef</span><span class="w"> </span><span class="n">getELFRelocationTypeName</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Machine</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Machine</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">ELF</span><span class="o">::</span><span class="no">EM_CPU0</span><span class="p">:</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;llvm/Support/ELFRelocs/Cpu0.def&quot;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Support/ELFRelocs/Cpu0.def</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#ifndef ELF_RELOC</span>
<span class="c1">#error &quot;ELF_RELOC must be defined&quot;</span>
<span class="c1">#endif</span>

<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">,</span>                <span class="mi">0</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">,</span>                  <span class="mi">2</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">,</span>                <span class="mi">5</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">,</span>                <span class="mi">6</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">,</span>             <span class="mi">7</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">,</span>             <span class="mi">8</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">,</span>               <span class="mi">9</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC16</span><span class="p">,</span>               <span class="mi">10</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">,</span>             <span class="mi">11</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GPREL32</span><span class="p">,</span>            <span class="mi">12</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">,</span>               <span class="mi">13</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_HI16</span><span class="p">,</span>           <span class="mi">22</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GOT_LO16</span><span class="p">,</span>           <span class="mi">23</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_RELGOT</span><span class="p">,</span>             <span class="mi">36</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GD</span><span class="p">,</span>             <span class="mi">42</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_LDM</span><span class="p">,</span>            <span class="mi">43</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_HI16</span><span class="p">,</span>       <span class="mi">44</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_DTP_LO16</span><span class="p">,</span>       <span class="mi">45</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_GOTTPREL</span><span class="p">,</span>       <span class="mi">46</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TPREL32</span><span class="p">,</span>        <span class="mi">47</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_HI16</span><span class="p">,</span>        <span class="mi">49</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_TLS_TP_LO16</span><span class="p">,</span>        <span class="mi">50</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_GLOB_DAT</span><span class="p">,</span>           <span class="mi">51</span><span class="p">)</span>
<span class="n">ELF_RELOC</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">,</span>          <span class="mi">127</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm/modify/llvm/lib/Support/Triple.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">Triple::getArchTypeName</span><span class="p">(</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cpu0</span><span class="p">:</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cpu0el</span><span class="p">:</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0el&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">Triple</span><span class="o">::</span><span class="n">getArchTypePrefix</span><span class="p">(</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Kind</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cpu0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">cpu0el</span><span class="p">:</span><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;cpu0&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">getArchTypeForLLVMName</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">Name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpu0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;cpu0el&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cpu0el</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">parseArch</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">ArchName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ArchName</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="p">.</span><span class="n">Cases</span><span class="p">(</span><span class="s">&quot;cpu0&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0eb&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0allegrex&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">Cases</span><span class="p">(</span><span class="s">&quot;cpu0el&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;cpu0allegrexel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0el</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">ObjectFormatType</span><span class="w"> </span><span class="n">getDefaultFormat</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Triple</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0el</span><span class="p">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">getArchPointerBitWidth</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="o">::</span><span class="n">ArchType</span><span class="w"> </span><span class="n">Arch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">Arch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">llvm</span><span class="o">::</span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">llvm</span><span class="o">::</span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0el</span><span class="p">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">Triple</span><span class="w"> </span><span class="n">Triple</span><span class="o">::</span><span class="n">get32BitArchVariant</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Triple</span><span class="w"> </span><span class="nf">T</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">getArch</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0</span><span class="p">:</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">Triple</span><span class="o">::</span><span class="no">cpu0el</span><span class="p">:</span>
<span class="w">  </span><span class="p">...</span>
<span class="w">    </span><span class="c1">// Already 32-bit.</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="cpu0-td">
<h3><a class="toc-backref" href="#id105" role="doc-backlink">创建初始的 Cpu0 .td 文件</a><a class="headerlink" href="#cpu0-td" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-2007">正如前一节所讨论的，LLVM使用目标描述文件（使用.td文件扩展名）来描述目标后端的各种组件。
例如，这些.td文件可以描述目标的寄存器集、指令集、指令的调度信息以及调用约定。
当您的后端正在编译时，LLVM附带的tablegen工具将这些.td文件转换为写入具有.inc扩展名的文件的C++源代码。
有关如何使用tablegen的更多信息，请参阅  <a class="footnote-reference brackets" href="#tblgen" id="id49" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a>。</p>
<p class="linemarker linemarker-2012">每个后端都有自己的 .td 文件来定义一些目标信息。这些文件的语法与 C++ 类似。
对于 Cpu0，目标描述文件称为 Cpu0Other.td，如下所示：</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0Other.td</p>
<p class="linemarker linemarker-2018">Cpu0Other.td 和 Cpu0.td 包含了一些其他的 .td 文件。</p>
<p class="linemarker linemarker-2020">Cpu0RegisterInfo.td（如下所示）描述了 Cpu0 的一组寄存器。
在这个文件中，我们可以看到每个寄存器都被赋予了一个名称。
例如，“def PC” 表示有一个名为 PC 的寄存器。除了寄存器信息，它还定义了寄存器类信息。
您可能有多个寄存器类，如 CPURegs、SR、C0Regs 和 GPROut。
GPROut 在 Cpu0RegisterInfoGPROutForOther.td 中定义，
其中包括除 SW 外的 CPURegs，因此 SW 在寄存器分配阶段不会被分配为输出寄存器。</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfo.td</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0RegisterInfoGPROutForOther.td</p>
<p class="linemarker linemarker-2034">在C++中，类通常提供了一个结构来布置一些数据和函数，而定义则用于为类的特定实例分配内存。例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Date</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// declare Date</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">day</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Date</span><span class="w"> </span><span class="n">birthday</span><span class="p">;</span><span class="w">  </span><span class="c1">// define birthday, an instance of Date</span>
</pre></div>
</div>
<p class="linemarker linemarker-2044">类 Date 有成员 year、month 和 day，但这些成员尚未属于实际对象。
通过定义名为 birthday 的 Date 实例，您为特定对象分配了内存，并可以设置该类实例的年、月和日。</p>
<p class="linemarker linemarker-2047">在 .td 文件中，class 描述了数据布局的结构，而 definitions 则充当类的具体实例。
如果您回顾 Cpu0RegisterInfo.td 文件，您会看到一个名为 Cpu0Reg 的类，
该类是从 LLVM 提供的 Register 类派生而来。
Cpu0Reg 继承了 Register 类中存在的所有字段。
“let HWEncoding = Enc” 意味着从参数 Enc 分配字段 HWEncoding。
由于 Cpu0 在指令格式中为 16 个寄存器保留了 4 位，分配的值范围从 0 到 15。
一旦将 0 到 15 分配给 HWEncoding，后端寄存器编号将从 llvm 寄存器类的函数中获取，
因为 TableGen 将自动设置该编号。</p>
<p class="linemarker linemarker-2056">def 关键字用于创建类的实例。在以下行中，将 ZERO 寄存器定义为 Cpu0GPRReg 类的成员：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="n">ZERO</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ZERO&quot;</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="linemarker linemarker-2063">零（ZERO）是这个寄存器的名称。创建Cpu0GPRReg类的特定实例时使用&lt;0，“ZERO”&gt;参数，
因此Enc字段设置为0，字符串n设置为ZERO。</p>
<p class="linemarker linemarker-2066">由于寄存器位于Cpu0命名空间中，您可以通过使用Cpu0::ZERO在后端C++代码中引用ZERO寄存器。</p>
<p class="linemarker linemarker-2068">请注意let表达式的使用：这些表达式允许您覆盖最初在超类中定义的值。
例如，在Cpu0Reg类中使用let Namespace = “Cpu0”将覆盖Register类中声明的默认命名空间。
Cpu0RegisterInfo.td还定义了CPURegs是RegisterClass类的一个实例，该类是一个内置的LLVM类。
RegisterClass是一组Register实例，因此CPURegs可以被描述为一组寄存器。</p>
<p class="linemarker linemarker-2073">Cpu0指令td命名为Cpu0InstrInfo.td，其内容如下：</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<p class="linemarker linemarker-2078">Cpu0InstrFormats.td 被 Cpu0InstInfo.td 包含如下：</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrFormats.td</p>
<p class="linemarker linemarker-2084">ADDiu是从FL继承的ArithLogicI类的实例，可以按如下方式扩展并获取成员值：</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ADDiu   : ArithLogicI&lt;0x09, &quot;addiu&quot;, add, simm16, immSExt16, CPURegs&gt;;

/// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
          Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
   !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
   [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
</pre></div>
</div>
<p class="linemarker linemarker-2099">So,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">op = 0x09</span>
<span class="go">instr_asm = “addiu”</span>
<span class="go">OpNode = add</span>
<span class="go">Od = simm16</span>
<span class="go">imm_type = immSExt16</span>
<span class="go">RC = CPURegs</span>
</pre></div>
</div>
<p class="linemarker linemarker-2110">扩展td的一些原则包括：</p>
<ul>
<li><p class="linemarker linemarker-2112">let: 意思覆盖父类中已存在的字段。
例如：let isReMaterializable = 1; 覆盖Target.td中类instruction的isReMaterializable字段。</p></li>
<li><p class="linemarker linemarker-2115">declaration: meaning declare a new field for this class.</p>
<p class="linemarker linemarker-2117">For instance: bits&lt;4&gt;  ra; declare ra field for class FL.</p>
</li>
</ul>
<p class="linemarker linemarker-2120">扩展的细节如下表所示：</p>
<table class="docutils align-default" id="id81">
<caption><span class="caption-text">ADDiu expand part I</span><a class="headerlink" href="#id81" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-2125">ADDiu</p></th>
<th class="head"><p class="linemarker linemarker-2125">ArithLogicI</p></th>
<th class="head"><p class="linemarker linemarker-2125">FL</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-2127">0x09</p></td>
<td><p class="linemarker linemarker-2127">op = 0x09</p></td>
<td><p class="linemarker linemarker-2127">Opcode = 0x09;</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2128">addiu</p></td>
<td><p class="linemarker linemarker-2128">instr_asm = “addiu”</p></td>
<td><p class="linemarker linemarker-2128">(outs GPROut:$ra);
!strconcat(“addiu”, “t$ra, $rb, $imm16”);</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2130">add</p></td>
<td><p class="linemarker linemarker-2130">OpNode = add</p></td>
<td><p class="linemarker linemarker-2130">[(set GPROut:$ra, (add CPURegs:$rb, immSExt16:$imm16))]</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2131">simm16</p></td>
<td><p class="linemarker linemarker-2131">Od = simm16</p></td>
<td><p class="linemarker linemarker-2131">(ins CPURegs:$rb, simm16:$imm16);</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2132">immSExt16</p></td>
<td><p class="linemarker linemarker-2132">imm_type = immSExt16</p></td>
<td><p class="linemarker linemarker-2132">Inst{15-0} = imm16;</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2133">CPURegs</p></td>
<td><p class="linemarker linemarker-2133">RC = CPURegs
isReMaterializable=1;</p></td>
<td><p class="linemarker linemarker-2134">Inst{23-20} = ra;
Inst{19-16} = rb;</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id82">
<caption><span class="caption-text">ADDiu expand part II</span><a class="headerlink" href="#id82" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p class="linemarker linemarker-2141">Cpu0Inst</p></th>
<th class="head"><p class="linemarker linemarker-2141">instruction</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p class="linemarker linemarker-2143">Namespace = “Cpu0”</p></td>
<td><p class="linemarker linemarker-2143">Uses = []; …</p></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2144">Inst{31-24} = 0x09;</p></td>
<td><p class="linemarker linemarker-2144">Size = 0; …</p></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2145">OutOperandList = GPROut:$ra;</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2146">InOperandList  = CPURegs:$rb,simm16:$imm16;</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2147">AsmString = “addiut$ra, $rb, $imm16”</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2148">pattern = [(set GPROut:$ra, (add RC:$rb, immSExt16:$imm16))]</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2149">Itinerary = IIAlu</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p class="linemarker linemarker-2150">TSFlags{3-0} = FrmL.value</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p class="linemarker linemarker-2151">DecoderNamespace = “Cpu0”</p></td>
<td></td>
</tr>
</tbody>
</table>
<p class="linemarker linemarker-2154">The td expanding is a lousy process.
Similarly, LD and ST instruction definition can be expanded in this way.
Please notice the Pattern =
[(set GPROut:$ra, (add RC:$rb, immSExt16:$imm16))] which include keyword
<strong>“add”</strong>.
The ADDiu with <strong>“add”</strong> is used in sub-section Instruction Selection of last
section.</p>
<p class="linemarker linemarker-2162">File Cpu0Schedule.td include the function units and pipeline stages information
as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0Schedule.td</p>
</section>
<section id="cmake">
<h3><a class="toc-backref" href="#id106" role="doc-backlink">编写 cmake 文件</a><a class="headerlink" href="#cmake" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-2172">Target/Cpu0 directory has two files CMakeLists.txt,
contents as follows,</p>
<p class="rubric">lbdex/chapters/Chapter2/CMakeLists.txt</p>
<p class="linemarker linemarker-2179">CMakeLists.txt 是 cmake 的构建信息，# 表示注释。在两个文件中，注释都以 # 开头。上述 CMakeLists.txt 中的 “tablegen(”
在 cmake/modules/TableGen.cmake 中定义如下：</p>
<p class="rubric">llvm/cmake/modules/TableGen.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>function(tablegen project ofn)
  ...
  add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${ofn}.tmp
    # Generate tablegen output in a temporary file.
    COMMAND ${${project}_TABLEGEN_EXE} ${ARGN} -I ${CMAKE_CURRENT_SOURCE_DIR}
  ...
endfunction()
...
macro(add_tablegen target project)
  ...
  if(LLVM_USE_HOST_TOOLS)
    if( ${${project}_TABLEGEN} STREQUAL &quot;${target}&quot; )
      if (NOT CMAKE_CONFIGURATION_TYPES)
        set(${project}_TABLEGEN_EXE &quot;${LLVM_NATIVE_BUILD}/bin/${target}&quot;)
      else()
        set(${project}_TABLEGEN_EXE &quot;${LLVM_NATIVE_BUILD}/Release/bin/${target}&quot;)
      endif()
  ...
endmacro()
</pre></div>
</div>
<p class="rubric">llvm/utils/TableGen/CMakeLists.txt</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_tablegen</span><span class="p">(</span><span class="s">llvm-tblgen</span><span class="w"> </span><span class="s">LLVM</span>
<span class="w">  </span><span class="s">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p class="linemarker linemarker-2212">在 llvm/utils/TableGen/CMakeLists.txt 中的“add_tablegen”，
使 Cpu0 CMakeLists.txt 中的“tablegen(” 成为 llvm-tblgen 的别名
（其中 ${project} = LLVM 和 ${project}_TABLEGEN_EXE = llvm-tblgen）。
在 lbdex/chapters/Chapter2/CMakeLists.txt 中的“tablegen(”,
“add_public_tablegen_target(Cpu0CommonTableGen)”以及下面的代码定义了一个名为“Cpu0CommonTableGen”的目标，
其输出文件为“Cpu0Gen*.inc”，如下所示：</p>
<p class="rubric">llvm/cmake/modules/TableGen.cmake</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>function(tablegen project ofn)
  ...
  set(TABLEGEN_OUTPUT ${TABLEGEN_OUTPUT} ${CMAKE_CURRENT_BINARY_DIR}/${ofn} PARENT_SCOPE)
  ...
endfunction()

# Creates a target for publicly exporting tablegen dependencies.
function(add_public_tablegen_target target)
  ...
  add_custom_target(${target}
    DEPENDS ${TABLEGEN_OUTPUT})
  ...
endfunction()
</pre></div>
</div>
<p class="linemarker linemarker-2236">由于在构建 LLVM 期间，执行文件 llvm-tblgen 在编译任何 llvm 后端源代码之前构建，因此 llvm-tblgen 总是为后端的 TableGen 请求准备就绪。</p>
<p class="linemarker linemarker-2238">本书通过功能将整个后端源代码分解，逐章添加代码。不要试图理解书中的所有内容，每章添加的代码也是一种阅读材料。要理解概念中的计算机相关知识，可以忽略源代码，但基于现有开放软件的实现则不行。在编程中，文档不能完全替代源代码。阅读源代码是开源开发中的重大机遇。</p>
<p class="linemarker linemarker-2240">CMakeLists.txt 存在于子目录 MCTargetDesc 和 TargetInfo 中。
这两个目录中的 MakeLists.txt 内容指示 llvm 生成 Cpu0Desc 和 Cpu0Info 库。
构建完成后，您将在构建目录的 lib/ 中找到三个库：
libLLVMCpu0CodeGen.a、libLLVMCpu0Desc.a 和 libLLVMCpu0Info.a。
更多详情请参阅“使用 CMake 构建 LLVM”  <a class="footnote-reference brackets" href="#id58" id="id50" role="doc-noteref"><span class="fn-bracket">[</span>28<span class="fn-bracket">]</span></a>。</p>
</section>
<section id="target-registration">
<h3><a class="toc-backref" href="#id107" role="doc-backlink">Target Registration</a><a class="headerlink" href="#target-registration" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-2249">你还必须通过TargetRegistry注册你的目标。注册后，llvm工具能够在运行时查找并使用你的目标。
TargetRegistry可以直接使用，
但对于大多数目标，应该使用辅助模板来为你处理工作。</p>
<p class="linemarker linemarker-2253">所有目标应声明一个全局的目标对象，该对象用于在注册过程中表示目标。
然后，在目标的 TargetInfo 库中，目标应定义该对象并使用 RegisterTarget 模板来注册目标。
例如，文件 TargetInfo/Cpu0TargetInfo.cpp 注册 TheCpu0Target 为大端和 TheCpu0elTarget 为小端，如下所示。</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0.h</p>
<p class="rubric">lbdex/chapters/Chapter2/TargetInfo/Cpu0TargetInfo.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">Cpu0TargetInfo</span><span class="o">.</span><span class="n">cpp</span> <span class="o">-</span> <span class="n">Cpu0</span> <span class="n">Target</span> <span class="n">Implementation</span> <span class="o">-------------------===//</span>
<span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#include &quot;Cpu0.h&quot;</span>
<span class="c1">#include &quot;llvm/IR/Module.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Target</span> <span class="n">llvm</span><span class="p">::</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">llvm</span><span class="p">::</span><span class="n">TheCpu0elTarget</span><span class="p">;</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">LLVMInitializeCpu0TargetInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0</span><span class="p">,</span>
        <span class="o">/*</span><span class="n">HasJIT</span><span class="o">=*/</span><span class="n">true</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="s2">&quot;cpu0&quot;</span><span class="p">,</span> <span class="s2">&quot;CPU0 (32-bit big endian)&quot;</span><span class="p">,</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">);</span>

  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="p">::</span><span class="n">cpu0el</span><span class="p">,</span>
        <span class="o">/*</span><span class="n">HasJIT</span><span class="o">=*/</span><span class="n">true</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="s2">&quot;cpu0el&quot;</span><span class="p">,</span> <span class="s2">&quot;CPU0 (32-bit little endian)&quot;</span><span class="p">,</span> <span class="s2">&quot;Cpu0&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter2/TargetInfo/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># llvm 10.0.0 change from add_llvm_library to add_llvm_component_library</span>
<span class="n">add_llvm_component_library</span><span class="p">(</span><span class="n">LLVMCpu0Info</span>
  <span class="n">Cpu0TargetInfo</span><span class="o">.</span><span class="n">cpp</span>

  <span class="n">LINK_COMPONENTS</span>
  <span class="n">Support</span>

  <span class="n">ADD_TO_COMPONENT</span>
  <span class="n">Cpu0</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="linemarker linemarker-2266">文件 Cpu0TargetMachine.cpp 和 MCTargetDesc/Cpu0MCTargetDesc.cpp 只是定义了空的初始化函数，因为我们当前没有注册任何内容。</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0TargetMachine.cpp</p>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<p class="rubric">lbdex/chapters/Chapter2/MCTargetDesc/CMakeLists.txt</p>
<p class="linemarker linemarker-2281">Please see “Target Registration” <a class="footnote-reference brackets" href="#target-reg" id="id51" role="doc-noteref"><span class="fn-bracket">[</span>29<span class="fn-bracket">]</span></a> for reference.</p>
</section>
<section id="build-libraries-and-td">
<h3><a class="toc-backref" href="#id108" role="doc-backlink">Build libraries and td</a><a class="headerlink" href="#build-libraries-and-td" title="Link to this heading"></a></h3>
<p class="linemarker linemarker-2287">Build steps <a class="reference external" href="https://github.com/Jonathan2251/lbd/blob/master/README.md">https://github.com/Jonathan2251/lbd/blob/master/README.md</a>.
We set llvm source code in /Users/Jonathan/llvm/debug/llvm and have llvm
debug-build in /Users/Jonathan/llvm/debug/build.
About how to build llvm, please refer here <a class="footnote-reference brackets" href="#clang" id="id52" role="doc-noteref"><span class="fn-bracket">[</span>30<span class="fn-bracket">]</span></a>.
In appendix A, we made a copy from /Users/Jonathan/llvm/debug/llvm to
/Users/Jonathan/llvm/test/llvm for working with my Cpu0 target backend.
Sub-directories llvm is for source code and build is for debug
build directory.</p>
<p class="linemarker linemarker-2296">Beside directory llvm/lib/Target/Cpu0, there are a couple of files modified to
support cpu0 new Target, which includes both the ID and name of machine and
relocation records listed in the early sub-section.
You can update your llvm working copy and find the modified files by
commands, cp -rf lbdex/llvm/modify/llvm/* &lt;yourllvm/workingcopy/sourcedir&gt;/.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:lbd Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd</span>
<span class="gp">118-165-78-230:lbd Jonathan$ </span>cp<span class="w"> </span>-rf<span class="w"> </span>lbdex/llvm/modify/llvm/*<span class="w"> </span>~/llvm/test/llvm/.
<span class="gp">118-165-78-230:lbd Jonathan$ </span>grep<span class="w"> </span>-R<span class="w"> </span><span class="s2">&quot;cpu0&quot;</span><span class="w"> </span>~/llvm/test/llvm/include
<span class="go">llvm/cmake/config-ix.cmake:elseif (LLVM_NATIVE_ARCH MATCHES &quot;cpu0&quot;)</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:#undef cpu0</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:    cpu0,       // For Tutorial Backend Cpu0</span>
<span class="go">llvm/include/llvm/ADT/Triple.h:    cpu0el,</span>
<span class="go">llvm/include/llvm/Support/ELF.h:  EF_CPU0_ARCH_32R2 = 0x70000000, // cpu032r2</span>
<span class="go">llvm/include/llvm/Support/ELF.h:  EF_CPU0_ARCH_64R2 = 0x80000000, // cpu064r2</span>
<span class="go">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-2316">Next configure the Cpu0 example code to chapter2 as follows,</p>
<p class="rubric">~/llvm/test/llvm/lib/Target/Cpu0/Cpu0SetChapter.h</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define CH       CH2</span>
</pre></div>
</div>
<p class="linemarker linemarker-2323">Beside configure chapter as above, I provide gen-chapters.sh that you
can get each chapter code as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:lbdex Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd/lbdex</span>
<span class="gp">118-165-78-230:lbdex Jonathan$ </span>bash<span class="w"> </span>gen-chapters.sh
<span class="gp">118-165-78-230:lbdex Jonathan$ </span>ls<span class="w"> </span>chapters
<span class="go">Chapter10_1   Chapter11_2     Chapter2        Chapter3_2...</span>
<span class="go">Chapter11_1   Chapter12_1     Chapter3_1      Chapter3_3...</span>
</pre></div>
</div>
<p class="linemarker linemarker-2336">Now, run the <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">and</span> <span class="pre">make</span></code> command to build td (the following cmake
command is for my setting),</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:build Jonathan$ </span>cmake<span class="w"> </span>-DCMAKE_CXX_COMPILER<span class="o">=</span>clang++
<span class="go">-DCMAKE_C_COMPILER=clang -DCMAKE_BUILD_TYPE=Debug -G &quot;Unix Makefiles&quot; ../llvm/</span>

<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Targeting XCore</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /Users/Jonathan/llvm/test/build</span>

<span class="gp">118-165-78-230:build Jonathan$ </span>make<span class="w"> </span>-j4

<span class="gp">118-165-78-230:build Jonathan$</span>
</pre></div>
</div>
<p class="linemarker linemarker-2355">After build, you can type command <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">–version</span></code> to find the cpu0 backend,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:build Jonathan$ </span>/Users/Jonathan/llvm/test/
<span class="go">build/bin/llc --version</span>
<span class="go">LLVM (http://llvm.org/):</span>
<span class="go">...</span>
<span class="go">  Registered Targets:</span>
<span class="go">  arm      - ARM</span>
<span class="go">  ...</span>
<span class="go">  cpp      - C++ backend</span>
<span class="go">  cpu0     - Cpu0</span>
<span class="go">  cpu0el   - Cpu0el</span>
<span class="go">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-2371">The <code class="docutils literal notranslate"><span class="pre">llc</span> <span class="pre">-version</span></code> can display Registered Targets <strong>“cpu0”</strong> and <strong>“cpu0el”</strong>,
because the code in file TargetInfo/Cpu0TargetInfo.cpp we made in last
sub-section “Target Registration” <a class="footnote-reference brackets" href="#asadasd" id="id53" role="doc-noteref"><span class="fn-bracket">[</span>31<span class="fn-bracket">]</span></a>.</p>
<p class="linemarker linemarker-2375">Let’s build lbdex/chapters/Chapter2 code as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-75-57:test Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test</span>
<span class="gp">118-165-75-57:test Jonathan$ </span>cp<span class="w"> </span>-rf<span class="w"> </span>lbdex/Cpu0<span class="w"> </span>~/llvm/test/llvm/lib/Target/.

<span class="gp">118-165-75-57:test Jonathan$ </span><span class="nb">cd</span><span class="w"> </span>~/llvm/test/build
<span class="gp">118-165-75-57:build Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/llvm/test/build</span>
<span class="gp">118-165-75-57:build Jonathan$ </span>rm<span class="w"> </span>-rf<span class="w"> </span>*
<span class="gp">118-165-75-57:build Jonathan$ </span>cmake<span class="w"> </span>-DCMAKE_CXX_COMPILER<span class="o">=</span>clang++
<span class="go">-DCMAKE_C_COMPILER=clang -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD=Cpu0</span>
<span class="go">-G &quot;Unix Makefiles&quot; ../llvm/</span>
<span class="go">...</span>
<span class="go">-- Targeting Cpu0</span>
<span class="go">...</span>
<span class="go">-- Configuring done</span>
<span class="go">-- Generating done</span>
<span class="go">-- Build files have been written to: /Users/Jonathan/llvm/test/build</span>
</pre></div>
</div>
<p class="linemarker linemarker-2397">In order to save time, we build Cpu0 target only by option
-DLLVM_TARGETS_TO_BUILD=Cpu0.
After that, you can find the *.inc files in directory
/Users/Jonathan/llvm/test/build/lib/Target/Cpu0 as follows,</p>
<p class="rubric">build/lib/Target/Cpu0/Cpu0GenRegisterInfo.inc</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">Cpu0</span><span class="w"> </span><span class="p">{</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">NoRegister</span><span class="p">,</span>
<span class="w">  </span><span class="n">AT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">EPC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="n">FP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">  </span><span class="n">GP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">  </span><span class="n">HI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">  </span><span class="n">LO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">  </span><span class="n">LR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">  </span><span class="n">PC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">  </span><span class="n">SP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span>
<span class="w">  </span><span class="n">SW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">  </span><span class="n">ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span>
<span class="w">  </span><span class="n">A0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span>
<span class="w">  </span><span class="n">A1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span>
<span class="w">  </span><span class="n">S0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span>
<span class="w">  </span><span class="n">S1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span>
<span class="w">  </span><span class="n">T0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">  </span><span class="n">T1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span>
<span class="w">  </span><span class="n">T9</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span>
<span class="w">  </span><span class="n">V0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span>
<span class="w">  </span><span class="n">V1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span>
<span class="w">  </span><span class="n">NUM_TARGET_REGS</span><span class="w">     </span><span class="c1">// 21</span>
<span class="p">};</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-2433">These *.inc are generated by llvm-tblgen at directory
build/lib/Target/Cpu0 where their input files are the Cpu0 backend
*.td files.
The llvm-tblgen is invoked by <strong>tablegen</strong> of
/Users/Jonathan/llvm/test/llvm/lib/Target/Cpu0/CMakeLists.txt.
These *.inc files will be included by Cpu0 backend *.cpp or *.h files and
compile into *.o further.
TableGen is the important tool illustrated in the early sub-section
“.td: LLVM’s Target Description Files” of this chapter.
List it again as follows,</p>
<p class="linemarker linemarker-2444">“The “mix and match” approach allows target authors to choose what makes sense
for their architecture and permits a large amount of code reuse across
different targets”.</p>
<p class="linemarker linemarker-2448">Details about TableGen are here <a class="footnote-reference brackets" href="#tblgen" id="id54" role="doc-noteref"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#tblgen-langintro" id="id55" role="doc-noteref"><span class="fn-bracket">[</span>33<span class="fn-bracket">]</span></a>
<a class="footnote-reference brackets" href="#tblgen-langref" id="id56" role="doc-noteref"><span class="fn-bracket">[</span>34<span class="fn-bracket">]</span></a>.</p>
<p class="linemarker linemarker-2452">Now try to run  command <code class="docutils literal notranslate"><span class="pre">llc</span></code> to compile input file ch3.cpp as follows,</p>
<p class="rubric">lbdex/input/ch3.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="linemarker linemarker-2459">First step, compile it with clang and get output ch3.bc as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/git/lbd/lbdex/input</span>
<span class="gp">118-165-78-230:input Jonathan$ </span>clang<span class="w"> </span>-target<span class="w"> </span>mips-unknown-linux-gnu<span class="w"> </span>-c
<span class="go">ch3.cpp -emit-llvm -o ch3.bc</span>
</pre></div>
</div>
<p class="linemarker linemarker-2468">As above, compile C to .bc by <code class="docutils literal notranslate"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></code> because
Cpu0 borrows the ABI from Mips.
Next step, transfer bitcode .bc to human readable text format as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:test Jonathan$ </span>llvm-dis<span class="w"> </span>ch3.bc<span class="w"> </span>-o<span class="w"> </span>-

<span class="go">// ch3.ll</span>
<span class="go">; ModuleID = &#39;ch3.bc&#39;</span>
<span class="go">target datalayout = &quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f3</span>
<span class="go">2:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:6</span>
<span class="go">4-S128&quot;</span>
<span class="go">target triple = &quot;mips-unknown-linux-gnu&quot;</span>

<span class="go">define i32 @main() nounwind uwtable {</span>
<span class="gp">  %</span><span class="nv">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>alloca<span class="w"> </span>i32,<span class="w"> </span>align<span class="w"> </span><span class="m">4</span>
<span class="go">  store i32 0, i32* %1</span>
<span class="go">  ret i32 0</span>
<span class="go">}</span>
</pre></div>
</div>
<p class="linemarker linemarker-2489">Now, when compiling ch3.bc will get the error message as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">118-165-78-230:input Jonathan$ </span>/Users/Jonathan/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o</span>
<span class="go">ch3.cpu0.s</span>
<span class="go">...</span>
<span class="go">... Assertion `target.get() &amp;&amp; &quot;Could not allocate target machine!&quot;&#39; failed</span>
<span class="go">...</span>
</pre></div>
</div>
<p class="linemarker linemarker-2500">At this point, we finish the Target Registration for Cpu0 backend.
The backend compiler command <code class="docutils literal notranslate"><span class="pre">llc</span></code> can recognize Cpu0 backend now.
Currently we just define target td files (Cpu0.td, Cpu0Other.td,
Cpu0RegisterInfo.td, …).
According to LLVM structure, we need to define our target machine and include
those td related files.
The error message says we didn’t define our target machine.
This book is a step-by-step backend delvelopment.
You can review the houndreds lines of Chapter2 example code to see how to do
the Target Registration.</p>
</section>
</section>
<section id="options-of-llc-for-debug">
<h2><a class="toc-backref" href="#id109" role="doc-backlink">Options of llc for debug</a><a class="headerlink" href="#options-of-llc-for-debug" title="Link to this heading"></a></h2>
<p class="linemarker linemarker-2515">llc –help-hidden</p>
<p class="linemarker linemarker-2517">The following options for llc need to give a input .bc or .ll file.</p>
<ul class="simple">
<li><p class="linemarker linemarker-2519">-debug:</p></li>
<li><p class="linemarker linemarker-2521">-debug-pass=Structure</p></li>
<li><p class="linemarker linemarker-2523">-print-after-all, -print-before-all</p></li>
<li><p class="linemarker linemarker-2525">-print-before=”pass” and -print-after=”pass”, eg. -print-before=”postra-machine-sink” and -print-after=”postra-machine-sink”. The pass name can be got as follows,</p></li>
</ul>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">CodeGen % pwd</span>
<span class="go">~/llvm/debug/llvm/lib/CodeGen</span>
<span class="go">CodeGen % grep -R &quot;INITIALIZE_PASS&quot; |grep sink</span>
<span class="go">./MachineSink.cpp:INITIALIZE_PASS(PostRAMachineSinking, &quot;postra-machine-sink&quot;,</span>
</pre></div>
</div>
<ul class="simple">
<li><p class="linemarker linemarker-2534">-view-dag-combine1-dags displays the DAG after being built, before the
first optimization pass.</p></li>
<li><p class="linemarker linemarker-2537">-view-legalize-dags displays the DAG before Legalization.</p></li>
<li><p class="linemarker linemarker-2539">-view-dag-combine2-dags displays the DAG before the second optimization
pass.</p></li>
<li><p class="linemarker linemarker-2542">-view-isel-dags displays the DAG before the Select phase.</p></li>
<li><p class="linemarker linemarker-2544">-view-sched-dags displays the DAG before Scheduling.</p></li>
<li><p class="linemarker linemarker-2546">-march=&lt;string&gt;, eg. march=mips;</p></li>
<li><p class="linemarker linemarker-2548">-relocation-model=static/pic</p></li>
<li><p class="linemarker linemarker-2550">-filetype=asm/obj</p></li>
</ul>
<p class="linemarker linemarker-2552">Use F.dump() in code where F is class Function for passes in llvm/lib/Transformation.</p>
</section>
<section id="options-of-opt">
<h2><a class="toc-backref" href="#id110" role="doc-backlink">Options of opt</a><a class="headerlink" href="#options-of-opt" title="Link to this heading"></a></h2>
<p class="linemarker linemarker-2557">Check from <cite>opt –help-hidden</cite> and LLVM passes <a class="footnote-reference brackets" href="#llvm-passes" id="id57" role="doc-noteref"><span class="fn-bracket">[</span>35<span class="fn-bracket">]</span></a>. Eg.</p>
<ul class="simple">
<li><p class="linemarker linemarker-2559"><cite>opt -dot-cfg input.ll</cite>: Print CFG of function to ‘dot’ file</p></li>
<li><p class="linemarker linemarker-2560">-dot-cfg-only : Print CFG of function to ‘dot’ file (with no function bodies)</p></li>
</ul>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="cpu0-chinese" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2563">Original Cpu0 architecture and ISA details (Chinese). <a class="reference external" href="http://ccckmit.wikidot.com/ocs:cpu0">http://ccckmit.wikidot.com/ocs:cpu0</a></p>
</aside>
<aside class="footnote brackets" id="cpu0-english" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2565">English translation of Cpu0 description. <a class="reference external" href="http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0">http://translate.google.com.tw/translate?js=n&amp;prev=_t&amp;hl=zh-TW&amp;ie=UTF-8&amp;layout=2&amp;eotf=1&amp;sl=zh-CN&amp;tl=en&amp;u=http://ccckmit.wikidot.com/ocs:cpu0</a></p>
</aside>
<aside class="footnote brackets" id="lb-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id11">1</a>,<a role="doc-backlink" href="#id12">2</a>,<a role="doc-backlink" href="#id13">3</a>,<a role="doc-backlink" href="#id14">4</a>)</span>
<p class="linemarker linemarker-2567">The difference between LB and LBu is signed and unsigned byte value expand to a word size. For example, After LB Ra, [Rb+Cx], Ra is 0xffffff80(= -128) if byte [Rb+Cx] is 0x80; Ra is 0x0000007f(= 127) if byte [Rb+Cx] is 0x7f. After LBu Ra, [Rb+Cx], Ra is 0x00000080(= 128) if byte [Rb+Cx] is 0x80; Ra is 0x0000007f(= 127) if byte [Rb+Cx] is 0x7f. Difference between LH and LHu is similar.</p>
</aside>
<aside class="footnote brackets" id="u-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id16">2</a>,<a role="doc-backlink" href="#id17">3</a>,<a role="doc-backlink" href="#id18">4</a>)</span>
<p class="linemarker linemarker-2569">The only difference between ADDu instruction and the ADD instruction is that the ADDU instruction never causes an Integer Overflow exception. SUBu and SUB is similar.</p>
</aside>
<aside class="footnote brackets" id="cond-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id21">1</a>,<a role="doc-backlink" href="#id22">2</a>)</span>
<p class="linemarker linemarker-2571">CMP is signed-compare while CMPu is unsigned. Conditions include the following comparisons: &gt;, &gt;=, ==, !=, &lt;=, &lt;. SW is actually set by the subtraction of the two register operands, and the flags indicate which conditions are present.</p>
</aside>
<aside class="footnote brackets" id="sra-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id19">1</a>,<a role="doc-backlink" href="#id20">2</a>)</span>
<p class="linemarker linemarker-2573">Rb ‘&gt;&gt; Cx, Rb ‘&gt;&gt; Rc: Shift with signed bit remain.</p>
</aside>
<aside class="footnote brackets" id="call-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">7</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2575">jsub cx is direct call for 24 bits value of cx while jalr $rb is indirect call for 32 bits value of register $rb.</p>
</aside>
<aside class="footnote brackets" id="jr-note" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id24">8</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2577">Both JR and RET has same opcode (actually they are the same instruction for Cpu0 hardware). When user writes “jr $t9” meaning it jumps to address of register $t9; when user writes “jr $lr” meaning it jump back to the caller function (since $lr is the return address). For user read ability, Cpu0 prints “ret $lr” instead of “jr $lr”.</p>
</aside>
<aside class="footnote brackets" id="java-cpp" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id29">9</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2579"><a class="reference external" href="https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B">https://en.wikipedia.org/wiki/Comparison_of_Java_and_C%2B%2B</a></p>
</aside>
<aside class="footnote brackets" id="aosa-book" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id28">2</a>)</span>
<p class="linemarker linemarker-2581">Chris Lattner, <strong>LLVM</strong>. Published in The Architecture of Open Source Applications. <a class="reference external" href="http://www.aosabook.org/en/llvm.html">http://www.aosabook.org/en/llvm.html</a></p>
</aside>
<aside class="footnote brackets" id="chapters-ex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id48">11</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2583"><a class="reference external" href="http://jonathan2251.github.io/lbd/doc.html#generate-cpu0-document">http://jonathan2251.github.io/lbd/doc.html#generate-cpu0-document</a></p>
</aside>
<aside class="footnote brackets" id="codegen" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">12</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2585"><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></p>
</aside>
<aside class="footnote brackets" id="langref" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id9">1</a>,<a role="doc-backlink" href="#id10">2</a>,<a role="doc-backlink" href="#id31">3</a>)</span>
<p class="linemarker linemarker-2587"><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></p>
</aside>
<aside class="footnote brackets" id="cmu-rac" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id32">14</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2589"><a class="reference external" href="https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L23-Register-Coalescing.pdf">https://www.cs.cmu.edu/afs/cs/academic/class/15745-s16/www/lectures/L23-Register-Coalescing.pdf</a></p>
</aside>
<aside class="footnote brackets" id="ra-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">15</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2591"><a class="reference external" href="https://en.wikipedia.org/wiki/Register_allocation">https://en.wikipedia.org/wiki/Register_allocation</a></p>
</aside>
<aside class="footnote brackets" id="dragonbooks-10-2-3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">16</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2593">Refer section 10.2.3 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</aside>
<aside class="footnote brackets" id="gnu" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id35">17</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2596"><a class="reference external" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">https://en.wikipedia.org/wiki/GNU_Compiler_Collection</a></p>
</aside>
<aside class="footnote brackets" id="gcc-frontend" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id36">18</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2598"><a class="reference external" href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection#Front_ends">https://en.wikipedia.org/wiki/GNU_Compiler_Collection#Front_ends</a></p>
</aside>
<aside class="footnote brackets" id="generic" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id37">19</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2600"><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html">https://gcc.gnu.org/onlinedocs/gccint/GENERIC.html</a></p>
</aside>
<aside class="footnote brackets" id="gimple" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id38">20</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2602"><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html</a></p>
</aside>
<aside class="footnote brackets" id="rtl" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id39">21</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2604"><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">https://gcc.gnu.org/onlinedocs/gccint/RTL.html</a></p>
</aside>
<aside class="footnote brackets" id="md" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id40">22</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2606"><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html#Machine-Desc">https://gcc.gnu.org/onlinedocs/gccint/Machine-Desc.html#Machine-Desc</a></p>
</aside>
<aside class="footnote brackets" id="llvm-ir-vs-gimple" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id41">23</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2608"><a class="reference external" href="https://stackoverflow.com/questions/40799696/how-is-gcc-ir-different-from-llvm-ir/40802063">https://stackoverflow.com/questions/40799696/how-is-gcc-ir-different-from-llvm-ir/40802063</a></p>
</aside>
<aside class="footnote brackets" id="null-pointer-ex" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id42">24</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2610"><a class="reference external" href="https://github.com/Jonathan2251/lbd/tree/master/References/null_pointer.cpp">https://github.com/Jonathan2251/lbd/tree/master/References/null_pointer.cpp</a> is an example.</p>
</aside>
<aside class="footnote brackets" id="null-pointer" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id43">25</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2613">Dereferencing a NULL Pointer:
contrary to popular belief, dereferencing a null pointer in C is undefined.
It is not defined to trap, and if you mmap a page at 0, it is not defined to access that page.
This falls out of the rules that forbid dereferencing wild pointers and the use of NULL as a sentinel,
from <a class="reference external" href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html</a>.
As link, <a class="reference external" href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html</a>.
In this case, the developer forgot to call “set”, did not crash with a null pointer dereference,
and their code broke when someone else did a debug build.</p>
</aside>
<aside class="footnote brackets" id="cfg-wiki" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id44">26</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2622"><a class="reference external" href="https://en.wikipedia.org/wiki/Control-flow_graph">https://en.wikipedia.org/wiki/Control-flow_graph</a></p>
</aside>
<aside class="footnote brackets" id="dragonbooks-8-5" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>27<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id45">1</a>,<a role="doc-backlink" href="#id46">2</a>)</span>
<p class="linemarker linemarker-2624">Refer section 8.5 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</aside>
<aside class="footnote brackets" id="id58" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id50">28</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2627"><a class="reference external" href="http://llvm.org/docs/CMake.html">http://llvm.org/docs/CMake.html</a></p>
</aside>
<aside class="footnote brackets" id="target-reg" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id51">29</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2629"><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration">http://llvm.org/docs/WritingAnLLVMBackend.html#target-registration</a></p>
</aside>
<aside class="footnote brackets" id="clang" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id52">30</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2631"><a class="reference external" href="http://clang.llvm.org/get_started.html">http://clang.llvm.org/get_started.html</a></p>
</aside>
<aside class="footnote brackets" id="asadasd" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id53">31</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2633"><a class="reference external" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a></p>
</aside>
<aside class="footnote brackets" id="tblgen" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>32<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id49">1</a>,<a role="doc-backlink" href="#id54">2</a>)</span>
<p class="linemarker linemarker-2635"><a class="reference external" href="http://llvm.org/docs/TableGen/index.html">http://llvm.org/docs/TableGen/index.html</a></p>
</aside>
<aside class="footnote brackets" id="tblgen-langintro" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id55">33</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2637"><a class="reference external" href="http://llvm.org/docs/TableGen/LangIntro.html">http://llvm.org/docs/TableGen/LangIntro.html</a></p>
</aside>
<aside class="footnote brackets" id="tblgen-langref" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id56">34</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2639"><a class="reference external" href="http://llvm.org/docs/TableGen/LangRef.html">http://llvm.org/docs/TableGen/LangRef.html</a></p>
</aside>
<aside class="footnote brackets" id="llvm-passes" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id57">35</a><span class="fn-bracket">]</span></span>
<p class="linemarker linemarker-2641"><a class="reference external" href="https://llvm.org/docs/Passes.html">https://llvm.org/docs/Passes.html</a></p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, laity000。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>